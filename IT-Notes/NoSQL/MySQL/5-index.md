---
sort: 5
---

# 索引

```danger
* 理解索引是如何工作的非常重要，应该根据这些理解来创建最合适的索引
* 而不是根据一些诸如 
    “在多列索引中将选择性最高的列放在第一列”
    或 “应该为WHERE子句中出现的所有列创建索引”
之类的经验法则及推论

* 如何判定索引是否合理——按响应时间来对查询进行分析
```

## 创建原则

```danger
尽量避免使用物理外键，影响写入性能。通过事物处理数据一致性(创建、更新、删除)
```

* innodb表【显式声明】索引
* 单个表上的【索引个数】不能超过5个
* 更新频繁的列不加索引
* 不使用多列主键，不使用UUID、MD5、HASH、字符串列做为主键
* 优先考虑【组合索引】，并把【区分度】(select count(distinct column)/总数)最高的字段放在最前面
```
【最左匹配，不支持跳跃】
区分度最高的列放在左边 
字段长度小的列放在左边
使用最频繁的列放在左边
经常用于范围查询的列放在右边
```
* 保证表里互相【不存在冗余索引】（组合索引能覆盖的索引要删除）
* 单个索引中每个【索引记录的长度】(EXPLAIN 分析SQL会有key_len数据)不能超过64KB

* 考虑加索引的列：

```sql
    SELECT、UPDATE、DELETE 语句中的WHERE从句中的列
    ORDER BY、GROUP BY、DISTINCT 中出现的列
    在多表 JOIN 的 SQL 里，保证被【驱动表的连接列】上有索引，这样 JOIN 执行效率最高
```


## 索引结构

* InnoDB和MyISAM存储引擎表，索引类型必须为BTREE。
* MEMORY表可以根据需要选择HASH或者BTREE类型索引。
* 聚簇索引——Innodb主键索引——叶子节点是行数据
* 非聚簇索引——Innodb辅助所以——叶子节点是行主键——未实现索引覆盖的查询场景需要回表

## 索引失效的原因

* 查询分析器任务使用索引的效率和全表扫描相当时会放弃使用索引(查询优化器也有开销)
* where条件里等号左右字段类型必须一致，否则(数据类型隐式转换)无法利用索引

```sql
字段为数值类型, where 条件传入 字符串类型 的数值, 索引有效
字段为字符串类型, where 条件传入 数值, 索引失效
```
* 查询数据量超过表行数的25%, 不会利用索引
* Like 左模糊无法利用索引
* 在索引列上会用函数或表达式，索引失效

* or连接

```sql
并不是所有的 or 都会使索引失效，
如果 or 连接的所有字段都设置了索引，是会走索引的，
一旦有一个字段没有索引，就会走全表扫描。
【解决方案】
可将 or 语句优化为 union ，然后在各个 where 条件上建立索引
```

* 分页查询，当limit起点较高时，索引失效

```sql
如：where status = 1 offset 10000 limit 20
【解决方案】
可先用过滤条件进行过滤，分页请求参数带上last_id
如：where  status = 1 and id > 10000 limit 20
```

* 使用 NOT IN 条件, 索引失效

```sql
使用 left join 或 not exists 来优化 not in 操作
```


## 索引长度计算

[索引长度公式](https://blog.csdn.net/sinat_32873711/article/details/106754951)

* 1.所有的索引字段，如果没有设置not null，则需要加一个字节。 
* 2.定长字段，int：4个字节、date：3、tinyiny：1、bigInt:8、datetime：5。 
* 3.对于变成字段varchar(n)，则有n+2字节，定长字符串char(n)：n。 
* 4.不同的字符集，1个字符占用字节数。latin1：1，gbk：2，utf8：3，utf8mb4：4。 
* 5.索引长度 char()、varchar()索引长度的计算公式：

```bash
Character Set：（字符集对应1,2,3,4）* 列长度+ 2(变长列—varchar) [ + 1(允许null) ]
```

