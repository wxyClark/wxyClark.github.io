# 事务&锁

[CSDN mysql数据库锁与隔离级别](https://blog.csdn.net/baidu_14922873/article/details/84777498)
[博客园 MySQL锁机制与隔离级别](https://www.cnblogs.com/aaron-agu/p/13461147.html)


| 表引擎   | 表锁  | 页锁  | 行锁  |
| ---- | ---- |---- |---- |
| InnoDB | √ | × | √ |
| MyISAM | × | × | × |

## 事务

事务的4个基本特征ACID

| name    | 特性  | 注释  | 怎样实现 |
| ---- | ---- |---- |---- |
| Atomic | 原子性 | 整体操作要么全部成功,要么全部失败。 | undo log |
| Consistency | 一致性 | 仅仅有合法的数据能够被写入数据库，否则事务应该将其回滚到最初状态。 | 业务代码逻辑 |
| Isolation | 隔离性 | 并行事务的改动必须与其它并行事务的改动相互独立。 | MVCC |
| Durability | 持久性 | 事务结束后，事务处理的结果必须可以得到固化。| 内存+redo log |

* 事务提交的时候通过 redo log 刷盘，宕机的时候可以从 redo log 恢复
* undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql


## 锁

* 共享锁(S)：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
```
若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。
这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
```
* 排他锁(X)：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
```
若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。
```
* 意向共享锁(IS)：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
* 意向排他锁(IX)：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

| 兼容性列表 | X | IX | S | IS |
| ---- | ---- |---- |
| X | 冲突 | 冲突 | 冲突 | 冲突 |
| IX | 冲突 | 兼容 | 冲突 | 兼容 |
| S | 冲突 | 冲突 | 兼容 | 兼容 |
| IS | 冲突 | 兼容 | 兼容 | 兼容 |

### MyISAM表锁：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）

* 加锁：lock tables tablename1 read, tablename2 read;
* 解锁：Unlock tables;
* 执行更新操作 （ UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。


### InnoDB行锁

* 乐观锁：假设认为数据一般情况下不会造成冲突，提交更新时，才会校验版本号是否有冲突。
* 悲观锁：默认认为对数据的访问一定会产生并发问题，为了提高并发效率，会将悲观锁细化为读锁与写锁
```
读锁，又称共享锁，多个连接在同一时间读取同一个资源，二者不相互干扰。
写锁，又叫排它锁，一个写锁会阻塞其他的写锁和读锁。
```

* 悲观锁是数据库自身机制来实现的

| 锁级别 | 开销 | 加锁速度 | 是否会出现死锁 | 锁定粒度 | 发生锁冲突概率 | 并发度 | 适合场景 |
| ---- | ---- |---- |---- |---- | ---- |---- |---- |
| 表级锁 | 开销小 | 加锁快 | 不会 | 大 | 最高 | 最低 | 查询 |
| 页面锁 | 表锁< 中↑ <行锁 | 表锁< 中↑ <行锁 | 会 | 行锁< 中↓ <表锁 | 表锁< 中↑ <行锁 | 一般 |  |
| 行级锁 | 开销大 | 加锁慢 | 会 | 小 | 最低 | 最高 | 在线事务处理(OLTP) |

* InnoDB 存储引擎的锁的算法有三种


| lock    | 名称  | 作用范围 |
| ---- | ---- |---- |
| Record lock | 记录锁 | 单个行记录上的锁 |
| Gap lock | 间隙锁 | 锁定一个范围，不包括记录本身 |
| Next-key lock : record+gap | 临键锁 | 锁定一个范围，包含记录本身 |

```danger
MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。
而这个加锁度使用到的机制就是 Next-Key Locks。
```

### 如何加锁

```danger
【MySQL的行锁是针对索引加的锁】，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。
```

* 意向锁是InnoDB自动加的，不需用户干预。
* update,delete,insert都会自动
* select 语句默认不会加任何锁类型
* select …for update 语句加排他锁
* select … lock in share mode 加共享锁
```
主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。
```

* 只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁，这个需要通过explain来确定查询是否走索引！
* 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。

## 死锁

通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。下面就通过实例来介绍几种死锁的常用方法。

* 1.在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。
* 2.程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。
* 3.在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。
* 4.在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。
* 5.当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。

如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。

## 隔离级别

```danger
InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。
```


| name | 事务隔离级别 | 脏读 | 不可重复读  | 幻读  |
| ---- | ---- | ---- |---- |---- |
| read-uncommitted| 读未提交 | 是 | 是 | 是 |
| read-committed| 读已提交(不可重复读) | 否 | 是 | 是 |
| repeatable-read| 可重复读 | 否 | 否 |是 |
| senalizable| 串行化 | 否 | 否 | 否 |