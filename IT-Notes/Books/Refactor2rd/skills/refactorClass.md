# 重构类

|中文名|英文名|时机|做法|意义 |
|----|----|----|----|---- |
|提炼类|Extract Class|1 一个大的类在处理多个不同的事情(这个类不纯洁了)<br>2 某个类做了应该有两个类做的事<br>3<br>4 |①确定分出去的部分要做什么事情<br>②创建一个新的类，表示从旧地方分离出来的责任<br>③旧类创建时，为新类初始化<br>④使用搬移函数手法将需要的方法搬移到新的类（搬移函数时候就将调用地方改名）<br>⑤删除多余的接口函数，并为新类的接口取一个适合自己的名字<br>⑥考虑是否将新的类开放为公共类|单一职责|
|内联类|Inline  Class|1 一个曾经有很多功能的类，在重构过程中，已经变成一个毫无单独职责的类<br>2 某个类没有做太多事情<br>3需要对两个类重新进行职责划分|①将需要内联的类中的所有对外可调用函数（也可能是字段）在目标类中新建一个对应的中间代理函数<br>②修改调用者，调用代理方法并测试<br>③将原函数中的相关方法（字段）搬移到新地方并测试<br>④原类变为空壳后就可以删除了|内聚|
| | | | | |
|隐藏委托关系|Hide Delegate|1 一个类需要隐藏其背后的类的方法或事件<br>2 一个客户端调用类的方法时候，必须知道隐藏在后面的委托关系才能调用|【**重复**】{<br>①在服务类（对外的类）中新建一个委托函数，让其调用受托类（背后的类）的相关方法<br>②修改所有客户端调用为这个委托函数<br>}<br>直到受托类全部被搬移完毕，移除服务类中返回受托类的函数|解耦<br>即使将来委托关系发生变化，变化也只会影响服务对象，而不会直接波及所有客户端。|
|移除中间人|Remove Middle Man|1 因为**隐藏委托关系**（当初可能是比较适合隐藏的）手法造成的现在转发函数越来越多<br>2 过度的**迪米特法则**造成的转发函数越来越多|①在服务类（对外）内为受托对象（背后的类）创建一个返回整个委托对象的函数<br>②客户端的调用转为连续的访问函数进行调用<br>③删除原本的中间代理函数<br><br>这能通过可自动化的重构手法来完成，你可以先对受托字段使用**封装变量**，再应用**内联函数**内联所有使用它的函数|AA|
| | | | | |
|搬移函数|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
|搬移字段|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
| | | | | |
|搬移语句到函数|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
|函数搬移到调用者|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
| | | | | |
|以函数调用替换内联代码|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
|替换算法|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
| | | | | |
|字段改名|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
|以查询取代派生变量|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
| | | | | |
|将引用对象改为值对象|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
|将值对象改为引用对象|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
| | | | | |
|AA|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|
|AA|AA|1 <br>2 <br>3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦<br>⑧|AA|

## 处理概括关系

| 名称 | 定义  | 用法 |
| ---- | ---- |---- |
| 字段上移（Pull Up Field） | 两个子类拥有相同的字段。 | 将该字段移至超类。 |
| 函数上移（Pull Up Method） | 有些函数，在各个子类中产生完全相同的结果。 | 将该函数移至超类。 |
| 构造函数本体上移（Pull Up ConstructorBody） | 你在各个子类中拥有一些构造函数，他们的本体几乎完全一致。 | 在超类中新建一个构造函数，并在子类构造函数中调用它。 |
| 函数下移（Push Down Method） | 超类中的某个函数只与部分（而非全部）子类有关。 | 将这个函数移到相关的那些子类去。 |
| 字段下移（Push Down Field） | 超类中的某个字段只被部分（而非全部）子类用到。 | 将这个字段移到需要它的那些子类去。 |
| 提炼子类（ExtractSubclass） | 类中的某些特性只被某些（而非全部）实例用到。 | 新建一个子类，将上面所说的那一部分特性移到子类中。 |
| 提炼超类（Extract Superclass） | 两个类有相似特性。 | 为这两个类建立一个超类，将相同特性移至超类。 |
| 提炼接口（ExtractInterface） | 若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。 | 将相同的子集提炼到一个独立接口中。 |
| 折叠继承体系（Collapse Hierarchy） | 超类和子类之间无太大差别。 | 将它们合为一体。 |
| 塑造模板函数（Form TemPlateMethod） | 你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上所有不同。 | 将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。<br>然后将原函数上移至超类。 |
| 以委托取代继承（Replace Inheritance withDelegation） | 某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。 | 在子类中新建一个字段用以保存超类；调整子类函数令它改而委托超类；然后去掉两者之间的继承关系。 |
| 以继承取代委托（Replace Delegation withInheritance） | 你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。 | 让委托类来继承受托类。
14.大型重构** |