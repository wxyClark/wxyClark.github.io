---
sort: 2
---

# 封装

封装字段、封装记录(数据)、封装函数、封装类

## 封装记录（Encapsulate Record）

| title | content |
| ---- | ---- |
| 场景 | 多个可变数据在多个地方使用 |
| 意义 |  |
| 定义 |  |
| 做法 |  |
| 注意 | 封装大型的数据结构时，我会更多关注更新操作。凸显更新操作，并将它们集中到一处地方，是此次封装过程最重要的一部分。 |


## 封装集合（Encapsulate Collection）

| title | content |
| ---- | ---- |
| 场景 |  |
| 意义 |  |
| 定义 |  |
| 做法 |  |
| 注意 | 但封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。<br>这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。<br><br>为避免此种情况，我会在类上提供一些修改集合的方法——通常是“添加”和“移除”方法。<br>这样就可使对集合的修改必须经过类，当程序演化变大时，我依然能轻易找出修改点。<br><br>不要让集合的取值函数返回原始集合，这就避免了客户端的意外修改。 |

## 以查询取代临时变量（Replace Temp with Query）

| title | content |
| ---- | ---- |
| 场景 |  |
| 意义 |  |
| 定义 |  |
| 做法 | 如果变量目前不是只读的，但是可以改造成只读变量，那就先改造它。<br>测试。<br>将为变量赋值的代码段提炼成函数。 |
| 注意 | 检查变量在使用前是否已经完全计算完毕，检查计算它的那段代码是否每次都能得到一样的值。<br> if (isCalcXx) |


## 提炼类（Extract Class）

| title | content |
| ---- | ---- |
| 场景 | 如果你发现子类化只影响类的部分特性，或如果你发现某些特性需要以一种方式来子类化，某些特性则需要以另一种方式子类化，这就意味着你需要分解原来的类。 |
| 意义 |  |
| 定义 |  |
| 做法 | 决定如何分解类所负的责任。<br>创建一个新的类，用以表现从旧类中分离出来的责任。<br>如果旧类剩下的责任与旧类的名称不符，为旧类改名。<br><br>构造旧类时创建一个新类的实例，建立“从旧类访问新类”的连接关系。<br>
对于你想搬移的每一个字段，运用【搬移字段】搬移之。每次更改后运行测试。<br>
使用【搬移函数】将必要函数搬移到新类。先搬移较低层函数（也就是“被其他函数调用”多于“调用其他函数”者）。每次更改后运行测试。<br>
检查两个类的接口，去掉不再需要的函数，必要时为函数重新取一个适合新环境的名字。<br>
决定是否公开新的类。如果确实需要，考虑对新类应用【将引用对象改为值对象】使其成为一个值对象。 |
| 注意 |  |

## 内联类（Inline Class）

| title | content |
| ---- | ---- |
| 场景 | 一个类不再承担足够责任，不再有单独存在的理由（这通常是因为此前的重构动作移走了这个类的责任） |
| 意义 |  |
| 定义 | 挑选这一“萎缩类”的最频繁用户（也是一个类），以本手法将“萎缩类”塞进另一个类中 |
| 做法 | 对于待内联类（源类）中的所有public函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类。<br>修改源类public方法的所有引用点，令它们调用目标类对应的委托方法。每次更改后运行测试。<br>将源类中的函数与数据全部搬移到目标类，每次修改之后进行测试，直到源类变成空壳为止。<br>删除源类，为它举行一个简单的“丧礼” |
| 注意 | 有时把相关元素一口气搬移到位更简单，但有时先用内联手法合并各自的上下文，再使用提炼手法再次分离它们会更合适。 |


## 隐藏委托关系（Hide Delegate）

| title | content |
| ---- | ---- |
| 场景 | 如果某些客户端先通过服务对象的字段得到另一个对象（受托类），然后调用后者的函数，那么客户就必须知晓这一层委托关系。<br>万一受托类修改了接口，变化会波及通过服务对象使用它的所有客户端。<br>可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。|
| 意义 | 即使将来委托关系发生变化，变化也只会影响服务对象，而不会直接波及所有客户端。 |
| 定义 |  |
| 做法 |  |
| 注意 |  |


## 移除中间人（Remove Middle Man）

| title | content |
| ---- | ---- |
| 场景 |  |
| 意义 |  |
| 定义 |  |
| 做法 | 为受托对象创建一个取值函数。<br>对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试。<br>替换完委托方法的所有调用点后，你就可以删掉这个委托方法了。<br>这能通过可自动化的重构手法来完成，你可以先对受托字段使用【封装变量】，再应用【内联函数】内联所有使用它的函数 |
| 注意 |  |


## 替换算法（Substitute Algorithm）

```tip
使用这项重构手法之前，我得确定自己已经尽可能分解了原先的函数。
```

| title | content |
| ---- | ---- |
| 场景 |  |
| 意义 |  |
| 定义 |  |
| 做法 | 整理一下待替换的算法，保证它已经被抽取到一个独立的函数中。<br>先只为这个函数准备测试，以便固定它的行为。<br>准备好另一个（替换用）算法。<br>执行静态检查。<br>运行测试，比对新旧算法的运行结果。如果测试通过，那就大功告成；否则，在后续测试和调试过程中，以旧算法为比较参照标准 |
| 注意 |  |

