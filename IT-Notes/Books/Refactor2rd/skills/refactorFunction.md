---
sort: 1
---

# 重新组织函数

```tip
最好能把大的修改拆成小的步骤，所以如果你既想修改函数名，又想添加参数最好分成两步来做。

不论何时，如果遇到了麻烦，请撤销修改，并改用迁移式做法）
```

|中文名|英文名|时机|做法|意义 |
|----|----|----|----|---- |
|封装变量|Encapsulate Variable|1 当我们在修改或者增加使用可变数据的时候<br>2 数据被大范围使用（设置值）<br> 3 对象、数组无外部变动需要内部一起改变的需求时候，最好返回一份副本|①创建封装函数(包含访问和更新函数)<br>②测试<br>③控制变量外部不可见(private、protected)<br>④测试|不可变性是强大的代码防腐剂。<br>数据被使用得越广，就越是值得花精力给它一个体面的封装。|
|变量改名|Rename Variable|1 变量/常量的名字不足以说明字段的意义<br>2 垃圾命名<br>3 如果在另一个代码库中使用了该变量，这就是一个“已发布变量”（published variable），此时不能进行这个重构。|①先用封装变量手法封装<br>②找到所有使用该变量的代码，修改变量名<br>③测试<br>④只作用于某个函数的直接替换即可<br>⑤替换过程中可以以新名字作为过渡。待全部替换完毕再删除旧的名字|表意准确|
|- -|- -|- -|- -|- - |
|提炼变量|Extract Variable|1 一段又臭又长的表达式<br>2 在多处地方使用这个值（可能是当前函数、当前类乃至于更大的如全局作用域）<br> 3 如果这个变量名在更宽的上下文中也有意义，我就会考虑将其暴露出来，通常以函数的形式。|①确保要提炼的表达式，对其他地方没有影响<br>②声明一个不可修改的变量，并用表达式作为该变量的值<br>【交替使用】{<br>③用新变量(或函数)取代原来的表达式<br>④测试<br>}<br>|局部变量可以帮助我们将表达式分解为比较容易管理的形式 |
|内联变量|Inline Variable|1 变量没有比当前表达式有什么更好的释义<br>2 变量妨碍了重构附近代码<br>3 有一个临时变量，只被一个简单表达式赋值一次|①检查确认变量赋值的右侧表达式不对其他地方造成影响<br>②确认是否为只读，如果没有声明只读，则要先让他只读，并测试<br>【交替使用】{<br>③找到使用变量的地方，直接改为右侧表达式<br>④测试<br>}<br>⑤删除该变量的声明点和赋值语句<br>⑥多个内联变量在一起，可以用**提炼函数**取代临时变量|简化调用链 |
|- -|- -|- -|- -|- - |
|提炼函数|Extract Function|1 当一段大函数内某一部分代码在做的事情是同一件事，并且自成体系，不与其他掺杂时<br>2 当代码展示的意图和真正想做的事情不是同一件时候<br>3 如果变量按值传递给提炼部分又在提炼部分被赋值，就必须多加小心<br><br>4 如果想不出一个更有意义的名称，这就是一个信号，可能我不应该提炼这块代码。|①以他要做什么事情来命名的函数待提炼代码复制到这个函数<br>②检查这个函数内的代码的作用域、变量<br>③编译查看函数内有没有报错<br>④替换源函数的被提炼代码替换为函数调用<br>⑤测试<br>⑥替换其他代码中是否有与被提炼的代码相同或相似之处|将意图与实现分开 |
|内联函数|Inline Function|1 函数内代码直观表达的意思与函数名字相同<br>2 有一堆杂乱无章的代码需要重构，可以先内联函数，再通过提炼函数合理重构<br> 3 非多态性函数（函数属于一个类，而这个类被继承） |①检查多态性(如果该函数属于某个超类，并且它具有多态性，那么就无法内联)<br>②找到所有调用点<br>③将函数所有调用点替换为函数本体（非一次性替换，可以分批次替换、适应新家、测试）<br>④删掉该函数的定义（也可能会不删除，比如我们放弃了有一些函数调用，因为重构为渐进式，非一次性）<br>⑤检查上下文有没有导致重复的变量名|间接性可能带来帮助，但非必要的间接性总是让人不舒服 ||
|- -|- -|- -|- -|- - |
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|- -|- -|- -|- -|- - |
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|- -|- -|- -|- -|- - |
|改变函数声明|Change Function Declaration|1 函数名字不够贴切函数所做的事情<br>2 函数参数增加<br> 3 函数参数减少<br>4 函数参数概念发生变化<br>5 函数因为某个参数导致的函数应用范围小(全局有很多类似的函数，在做着类似的事情)|①对函数内部进行重构（如果有必要的话）<br>②使用提炼函数手法，将函数体提炼成一个新函数(加后缀：old、new)<br>③在新函数内做我们的变更（新增参数、删除参数、改变参数释义等）<br>④改变函数调用的地方（如果是新增、修改、删除参数）<br>⑤测试<br>⑥对旧函数使用内联函数来调用或返回新函数<br>⑦如果使用了临时名字，使用改变函数声明将其改回原来的名字（这时候就要删除旧函数了）<br>⑧测试|下一次再看到这段代码时，我就不用再费力搞懂其中到底在干什么。<br><br>修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合|
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|- -|- -|- -|- -|- - |
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|- -|- -|- -|- -|- - |
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|
|AA|AA|1 <br>2 <br> 3 <br>4 |①<br>②<br>③<br>④<br>⑤<br>⑥<br>⑦|AA|

## 8函数组合成类（Combine Functions into Class）

```tip
如果在另一个代码库中使用了该变量，这就是一个“已发布变量”（published variable），此时不能进行这个重构。
```

|title|content |
|----|---- |
|场景|如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数），我就认为，是时候组建一个类了。 |
|意义|类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用，并且这样一个对象也可以更方便地传递给系统的其他部分 |
|定义||
|做法||
|注意||

```tips
【函数组合成变换】的替代方案是【函数组合成类】，后者的做法是先用源数据创建一个类，再把相关的计算逻辑搬移到类中。

这两个重构手法都很有用，我常会根据代码库中已有的编程风格来选择使用其中哪一个。

不过，两者有一个重要的区别：如果代码中会对源数据做更新，那么使用类要好得多；如果使用变换，派生数据会被存储在新生成的记录中，一旦源数据被修改，我就会遭遇数据不一致。
```

## 9函数组合成变换（Combine Functions into Transform）

```tip
如果在另一个代码库中使用了该变量，这就是一个“已发布变量”（published variable），此时不能进行这个重构。
```

|title|content |
|----|---- |
|场景|在软件中，经常需要把数据“喂”给一个程序，让它再计算出各种派生信息。<br>这些派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复。<br>我更愿意把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。 |
|意义|采用数据变换（transform）函数：这种函数接受源数据作为输入，计算出所有的派生数据，将派生数据以字段形式填入输出数据。<br>有了变换函数，我就始终只需要到变换函数中去检查计算派生数据的逻辑 |
|定义||
|做法||
|注意||


## 将查询函数和修改函数分离（Separate Query from Modifier）

|title|content |
|----|---- |
|场景|某个函数既做查询，又做修改。 |
|定义|建立两个不同的函数，其中一个负责查询，另一个负责修改 |
|注意||