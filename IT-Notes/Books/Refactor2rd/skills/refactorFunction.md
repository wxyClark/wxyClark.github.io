---
sort: 1
---

# 重新组织函数

## 提炼函数(Extract Function)


| title | content |
| ---- | ---- |
| 意义 | 将意图与实现分开| 
| 定义 | 浏览一段代码，理解其作用，然后将其提炼到一个独立的函数中，并以这段代码的用途为这个函数命名。| 
| 做法 | 创造一个新函数，根据这个函数的意图来对它命名（以它“做什么”来命名，而不是以它“怎样做”命名）| 
| 注意 | 如果想不出一个更有意义的名称，这就是一个信号，可能我不应该提炼这块代码。<br> 如果变量按值传递给提炼部分又在提炼部分被赋值，就必须多加小心 | 

## 内联函数(Extract Function)

| title | content |
| ---- | ---- |
| 意义 | 间接性可能带来帮助，但非必要的间接性总是让人不舒服 |
| 定义 |  |
| 做法 | 检查函数，确定它不具多态性。 <br> 如果该函数属于一个类，并且有子类继承了这个函数，那么就无法内联。  <br> 找出这个函数的所有调用点。 <br> 将这个函数的所有调用点都替换为函数本体。 <br> 每次替换之后，执行测试。 <br> 不必一次完成整个内联操作。如果某些调用点比较难以内联，可以等到时机成熟后再来处理。<br>删除该函数的定义。 |
| 注意 |  |

## 提炼变量（Extract Variable）  

| title | content |
| ---- | ---- |
| 场景 | 表达式有可能非常复杂而难以阅读。<br>如果这个变量名在更宽的上下文中也有意义，我就会考虑将其暴露出来，通常以函数的形式。 |
| 意义 | 局部变量可以帮助我们将表达式分解为比较容易管理的形式 |
| 定义 |  |
| 做法 | 确认要提炼的表达式没有副作用。<br> 声明一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值。<br>用这个新变量取代原来的表达式。<br>测试。|
| 注意 |  |

## 内联变量（Inline Variable）   

| title | content |
| ---- | ---- |
| 场景 |  |
| 意义 |  |
| 定义 |  |
| 做法 | 检查确认变量赋值语句的右侧表达式没有副作用。<br>如果变量没有被声明为不可修改，先将其变为不可修改，并执行测试。<br>这是为了确保该变量只被赋值一次。<br>
找到第一处使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式。<br>测试。<br>重复前面两步，逐一替换其他所有使用该变量的地方。<br>删除该变量的声明点和赋值语句。<br>测试。|
| 注意 |  |

## 改变函数声明（Change Function Declaration）   

修改函数名：在确保不重复的情况下，新函数使用旧的函数名，将旧的函数名添加Old后缀，测试函数的行为没有改变后，修改新函数名称，替换旧函数的调用

| title | content |
| ---- | ---- |
| 场景 | 如果我看到一个函数的名字不对，一旦发现了更好的名字，就得尽快给函数改名。 |
| 意义 | 下一次再看到这段代码时，我就不用再费力搞懂其中到底在干什么。<br>修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合 |
| 定义 |  |
| 做法 | 先写一句注释描述这个函数的用途，再把这句注释变成函数的名字 <br>如果想要移除一个参数，需要先确定函数体内没有使用该参数。 <br>修改函数声明，使其成为你期望的状态。 <br>找出所有使用旧的函数声明的地方，将它们改为使用新的函数声明。 <br>测试。 |
| 注意 | 最好能把大的修改拆成小的步骤，所以如果你既想修改函数名，又想添加参数，最好分成两步来做。 |


## 封装变量（Encapsulate Variable）

```tip
不可变性是强大的代码防腐剂。

数据被使用得越广，就越是值得花精力给它一个体面的封装。
```

| title | content |
| ---- | ---- |
| 场景 | 如果想要搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装所有对该数据的访问。|
| 意义 | 对于所有可变的数据，只要它的作用域超出单个函数，我就会将其封装起来，只允许通过函数访问。数据的作用域越大，封装就越重要。 |
| 定义 |  |
| 做法 |  |
| 注意 |  |

## 变量改名（Rename Variable） 

```tip
如果在另一个代码库中使用了该变量，这就是一个“已发布变量”（published variable），此时不能进行这个重构。
```

| title | content |
| ---- | ---- |
| 场景 |  |
| 意义 |  |
| 定义 |  |
| 做法 |  |
| 注意 |  |

## 函数组合成类（Combine Functions into Class）

```tip
如果在另一个代码库中使用了该变量，这就是一个“已发布变量”（published variable），此时不能进行这个重构。
```

| title | content |
| ---- | ---- |
| 场景 | 如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数），我就认为，是时候组建一个类了。 |
| 意义 | 类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用，并且这样一个对象也可以更方便地传递给系统的其他部分 |
| 定义 |  |
| 做法 |  |
| 注意 |  |

```tips
【函数组合成变换】的替代方案是【函数组合成类】，后者的做法是先用源数据创建一个类，再把相关的计算逻辑搬移到类中。

这两个重构手法都很有用，我常会根据代码库中已有的编程风格来选择使用其中哪一个。

不过，两者有一个重要的区别：如果代码中会对源数据做更新，那么使用类要好得多；如果使用变换，派生数据会被存储在新生成的记录中，一旦源数据被修改，我就会遭遇数据不一致。
```

## 函数组合成变换（Combine Functions into Transform）

```tip
如果在另一个代码库中使用了该变量，这就是一个“已发布变量”（published variable），此时不能进行这个重构。
```

| title | content |
| ---- | ---- |
| 场景 | 在软件中，经常需要把数据“喂”给一个程序，让它再计算出各种派生信息。<br>这些派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复。<br>我更愿意把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。 |
| 意义 | 采用数据变换（transform）函数：这种函数接受源数据作为输入，计算出所有的派生数据，将派生数据以字段形式填入输出数据。<br>有了变换函数，我就始终只需要到变换函数中去检查计算派生数据的逻辑 |
| 定义 |  |
| 做法 |  |
| 注意 |  |


## 拆分阶段（Split Phase）

```tip
如果在另一个代码库中使用了该变量，这就是一个“已发布变量”（published variable），此时不能进行这个重构。
```

| title | content |
| ---- | ---- |
| 场景 | 一段代码在同时处理两件不同的事(如一个大函数 或 一个遍历 返回两个变量) |
| 意义 | 到了需要修改的时候，我就可以单独处理每个主题，而不必同时在脑子里考虑两个不同的主题 |
| 定义 | 就是把一大段行为分成顺序执行的两个阶段,每个步骤负责的任务全然不同 |
| 做法 |  |
| 注意 |  |
