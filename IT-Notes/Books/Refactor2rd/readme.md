---
sort: 2
---

# 重构——改善既有代码的设计(第2版)

[《重构改善既有代码的设计第2版》](https://refactoring.com/)

```danger
所谓好，就是更少的坏味道

重构的时候不开发功能

开发功能的时候不重构

无论重构还是优化新能，都要先准备好测试代码，确保不改变代码行为
```

## 意义

* 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
* 不改变外在行为，而提高代码质量，以改进程序的内部结构
* 使代码更容易被人读懂，更方便修改
* 可以先实现，再优化；简化开发过程
* 重构是理解软件的最快方式
* 重构可以很好地帮助我们理解遗留系统。
* 通过重构，我就把脑子里的理解转移到了代码本身


## 相关书籍

* 《解析极限编程》
* 《修改代码的艺术》
* 《数据库重构》
  
    并行修改:
> 数据库重构最好是分散到多次生产发布来完成，这样即便某次修改在生产数据库上造成了问题，也比较容易回滚。
> 确定没有bug之后，我再删除已经没人使用的旧字段。


## 格言

```danger
全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。
```

* 唯有能写出人类容易理解的代码的，才是优秀的程序员。
* 本质上说，重构就是在代码写好之后改进它的设计。
* 改进设计的一个重要方向就是消除重复代码
* 事不过三，三则重构
* 好代码的检验标准就是人们是否能轻而易举地修改它。
* 好代码应该直截了当：有人需要修改代码时，他们应能轻易找到修改点，应该能快速做出更改，而不易引入其他错误。
* 我比较喜欢让每个函数都只返回一个值，所以我会安排多个函数，用以返回多个值
* 代码被阅读和被修改的次数远远多于它被编写的次数。
* 设计模式为重构提供了目标。然而“确定目标”只是问题的一部分而已，改造程序以达到目标，是另一个难题。
* 尽管编写测试需要花费时间，但却为我节省下可观的调试时间
* 要将我的理解转化到代码里，得先将这块代码抽取成一个独立的函数，按它所干的事情给它命名
* 设计耐久性假说”：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。
* 一旦我需要思考“这段代码到底在做什么”，我就会自问：能不能重构这段代码，令其一目了然？
* 重构不是与编程割裂的行为。你不会专门安排时间重构，正如你不会专门安排时间写if语句。
* 优秀的程序员知道，添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入
* 自测试代码是极限编程的另一个重要组成部分，也是持续交付的关键环节。
* 糟糕的程序结构可以慢慢理顺，把程序从一块顽石打磨成美玉。
* 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的。
* 三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应。
* 如果你一视同仁地优化所有代码，90％的优化工作都是白费劲的，因为被你优化的代码大多很少被执行。
* 很多人经常不愿意给程序元素改名，觉得不值得费这个劲，但好的名字能节省未来用在猜谜上的大把时间。
* 如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题
* 据我们的经验，活得最长、最好的程序，其中的函数都比较短
* 就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。
* 不必在意数据泥团只用上新对象的一部分字段，只要以新对象取代两个（或更多）字段，就值得这么做。
* 大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等
* 一个体面的类型，至少能包含一致的显示逻辑，在用户界面上需要显示时可以使用
* 既然不愿意支持超类的接口，就不要虚情假意地糊弄继承体系
* 当我想好代码中应该有哪些关节时，才能使代码随着我的理解而演进。
* 如果我发现做一件事可以有更清晰的方式，我就会用比较清晰的方式取代复杂的方式。
