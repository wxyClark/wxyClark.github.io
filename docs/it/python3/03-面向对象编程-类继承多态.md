# Python 面向对象编程：类、继承与多态

## 一、类与对象

### 1.1 类的定义

```python
# 基本类定义
class Person:
    pass

# 创建对象
person = Person()
print(type(person))  # <class '__main__.Person'>
```

### 1.2 类属性与实例属性

```python
class Student:
    # 类属性（所有实例共享）
    school = "清华大学"

    def __init__(self, name, age):
        # 实例属性（每个实例独立）
        self.name = name
        self.age = age

# 创建实例
student1 = Student("张三", 20)
student2 = Student("李四", 21)

# 访问实例属性
print(student1.name)  # 张三
print(student2.name)  # 李四

# 访问类属性
print(student1.school)  # 清华大学
print(student2.school)  # 清华大学

# 修改类属性（影响所有实例）
Student.school = "北京大学"
print(student1.school)  # 北京大学
print(student2.school)  # 北京大学

# 修改实例属性（不影响其他实例）
student1.name = "王五"
print(student1.name)  # 王五
print(student2.name)  # 李四
```

### 1.3 方法定义

```python
class Calculator:
    # 实例方法（第一个参数是 self）
    def add(self, a, b):
        return a + b

    # 类方法（第一个参数是 cls）
    @classmethod
    def info(cls):
        return f"这是一个计算器类：{cls.__name__}"

    # 静态方法（不需要 self 或 cls）
    @staticmethod
    def multiply(a, b):
        return a * b

# 使用方法
calc = Calculator()
print(calc.add(3, 5))          # 8
print(Calculator.info())      # 这是一个计算器类：Calculator
print(Calculator.multiply(3, 5))  # 15
```

### 1.4 构造方法与析构方法

```python
class FileHandler:
    def __init__(self, filename):
        print(f"打开文件：{filename}")
        self.filename = filename

    def __del__(self):
        print(f"关闭文件：{self.filename}")

# 创建和销毁对象
handler = FileHandler("data.txt")
del handler  # 手动销毁
```

### 1.5 实际应用场景

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance

    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
            print(f"存款 {amount} 元，当前余额：{self.balance} 元")
        else:
            print("存款金额必须大于0")

    def withdraw(self, amount):
        if 0 < amount <= self.balance:
            self.balance -= amount
            print(f"取款 {amount} 元，当前余额：{self.balance} 元")
        else:
            print("取款金额无效或余额不足")

    def get_balance(self):
        return self.balance

# 使用银行账户类
account = BankAccount("张三", 1000)
account.deposit(500)
account.withdraw(300)
print(f"最终余额：{account.get_balance()} 元")
```

## 二、封装

### 2.1 私有属性和方法

```python
class Person:
    def __init__(self, name, age):
        self.name = name          # 公有属性
        self._age = age           # 保护属性（约定）
        self.__salary = 5000      # 私有属性

    def get_salary(self):
        return self.__salary

    def set_salary(self, salary):
        if salary > 0:
            self.__salary = salary

    def __private_method(self):
        print("这是私有方法")

    def public_method(self):
        self.__private_method()
        print("这是公有方法")

# 访问控制
person = Person("张三", 25)
print(person.name)           # 可以访问
print(person._age)           # 可以访问（但不推荐）
# print(person.__salary)    # 不能直接访问（会报错）
print(person.get_salary())   # 通过方法访问

person.public_method()
# person.__private_method()  # 不能直接调用
```

### 2.2 属性装饰器（property）

```python
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def celsius(self):
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value

    @property
    def fahrenheit(self):
        return self._celsius * 9 / 5 + 32

    @fahrenheit.setter
    def fahrenheit(self, value):
        self._celsius = (value - 32) * 5 / 9

# 使用属性
temp = Temperature(25)
print(temp.celsius)      # 25
print(temp.fahrenheit)   # 77.0

temp.celsius = 30
print(temp.fahrenheit)   # 86.0

temp.fahrenheit = 86
print(temp.celsius)      # 30.0
```

### 2.3 实际应用场景

```python
class ShoppingCart:
    def __init__(self):
        self._items = []
        self._total = 0

    def add_item(self, name, price, quantity=1):
        self._items.append({"name": name, "price": price, "quantity": quantity})
        self._total += price * quantity

    def remove_item(self, name):
        for item in self._items:
            if item["name"] == name:
                self._total -= item["price"] * item["quantity"]
                self._items.remove(item)
                break

    @property
    def items(self):
        return self._items.copy()

    @property
    def total(self):
        return self._total

    def clear(self):
        self._items.clear()
        self._total = 0

# 使用购物车类
cart = ShoppingCart()
cart.add_item("苹果", 5, 2)
cart.add_item("香蕉", 3, 3)
print(f"商品：{cart.items}")
print(f"总价：{cart.total} 元")

cart.remove_item("苹果")
print(f"商品：{cart.items}")
print(f"总价：{cart.total} 元")
```

## 三、继承

### 3.1 基本继承

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def eat(self):
        print(f"{self.name} 正在吃东西")

    def sleep(self):
        print(f"{self.name} 正在睡觉")

class Dog(Animal):
    def bark(self):
        print(f"{self.name} 正在汪汪叫")

class Cat(Animal):
    def meow(self):
        print(f"{self.name} 正在喵喵叫")

# 使用继承
dog = Dog("旺财")
dog.eat()    # 继承的方法
dog.bark()   # 自己的方法

cat = Cat("咪咪")
cat.sleep()  # 继承的方法
cat.meow()   # 自己的方法
```

### 3.2 方法重写

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} 发出声音")

class Dog(Animal):
    def speak(self):
        print(f"{self.name} 汪汪叫")

class Cat(Animal):
    def speak(self):
        print(f"{self.name} 喵喵叫")

# 方法重写
dog = Dog("旺财")
dog.speak()  # 旺财 汪汪叫

cat = Cat("咪咪")
cat.speak()  # 咪咪 喵喵叫
```

### 3.3 调用父类方法

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} 发出声音")

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 调用父类构造方法
        self.breed = breed

    def speak(self):
        super().speak()  # 调用父类方法
        print(f"{self.name} 汪汪叫")

# 使用 super()
dog = Dog("旺财", "金毛")
dog.speak()
print(f"品种：{dog.breed}")
```

### 3.4 多重继承

```python
class Flyable:
    def fly(self):
        print("可以飞行")

class Swimmable:
    def swim(self):
        print("可以游泳")

class Duck(Flyable, Swimmable):
    def quack(self):
        print("嘎嘎叫")

# 多重继承
duck = Duck()
duck.fly()    # 可以飞行
duck.swim()   # 可以游泳
duck.quack()  # 嘎嘎叫

# 方法解析顺序（MRO）
print(Duck.__mro__)
# (<class '__main__.Duck'>, <class '__main__.Flyable'>, <class '__main__.Swimmable'>, <class 'object'>)
```

### 3.5 实际应用场景

```python
class Employee:
    def __init__(self, name, base_salary):
        self.name = name
        self.base_salary = base_salary

    def calculate_salary(self):
        return self.base_salary

    def display_info(self):
        print(f"姓名：{self.name}，工资：{self.calculate_salary()} 元")

class Manager(Employee):
    def __init__(self, name, base_salary, bonus):
        super().__init__(name, base_salary)
        self.bonus = bonus

    def calculate_salary(self):
        return self.base_salary + self.bonus

class Developer(Employee):
    def __init__(self, name, base_salary, overtime_hours, overtime_rate=50):
        super().__init__(name, base_salary)
        self.overtime_hours = overtime_hours
        self.overtime_rate = overtime_rate

    def calculate_salary(self):
        return self.base_salary + self.overtime_hours * self.overtime_rate

# 使用继承
manager = Manager("张三", 10000, 5000)
manager.display_info()  # 姓名：张三，工资：15000 元

developer = Developer("李四", 8000, 40)
developer.display_info()  # 姓名：李四，工资：10000 元
```

## 四、多态

### 4.1 方法重写实现多态

```python
class Shape:
    def area(self):
        pass

    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

    def perimeter(self):
        return 2 * 3.14 * self.radius

# 多态使用
shapes = [Rectangle(5, 3), Circle(4)]
for shape in shapes:
    print(f"面积：{shape.area():.2f}，周长：{shape.perimeter():.2f}")
```

### 4.2 鸭子类型（Duck Typing）

```python
class Duck:
    def quack(self):
        print("嘎嘎叫")

    def fly(self):
        print("鸭子在飞")

class Person:
    def quack(self):
        print("人在模仿鸭子叫")

    def fly(self):
        print("人在模仿鸭子飞")

def make_it_quack(obj):
    obj.quack()
    obj.fly()

# 鸭子类型：不关心对象类型，只关心是否有相应方法
duck = Duck()
person = Person()

make_it_quack(duck)    # 嘎嘎叫，鸭子在飞
make_it_quack(person)  # 人在模仿鸭子叫，人在模仿鸭子飞
```

### 4.3 抽象基类（ABC）

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

    @abstractmethod
    def move(self):
        pass

class Dog(Animal):
    def speak(self):
        print("汪汪叫")

    def move(self):
        print("跑步")

class Cat(Animal):
    def speak(self):
        print("喵喵叫")

    def move(self):
        print("跳跃")

# 抽象类不能实例化
# animal = Animal()  # TypeError

# 子类必须实现所有抽象方法
dog = Dog()
dog.speak()
dog.move()
```

### 4.4 实际应用场景

```python
class PaymentProcessor(ABC):
    @abstractmethod
    def process(self, amount):
        pass

class CreditCardPayment(PaymentProcessor):
    def process(self, amount):
        print(f"信用卡支付：{amount} 元")
        return True

class AlipayPayment(PaymentProcessor):
    def process(self, amount):
        print(f"支付宝支付：{amount} 元")
        return True

class WeChatPayment(PaymentProcessor):
    def process(self, amount):
        print(f"微信支付：{amount} 元")
        return True

def make_payment(processor, amount):
    if processor.process(amount):
        print("支付成功")
    else:
        print("支付失败")

# 多态使用
payments = [
    CreditCardPayment(),
    AlipayPayment(),
    WeChatPayment()
]

for payment in payments:
    make_payment(payment, 100)
    print("---")
```

## 五、特殊方法（魔术方法）

### 5.1 字符串表示方法

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Point({self.x}, {self.y})"

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

point = Point(3, 4)
print(str(point))   # Point(3, 4)
print(repr(point))  # Point(x=3, y=4)
```

### 5.2 比较方法

```python
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def __eq__(self, other):
        return self.score == other.score

    def __lt__(self, other):
        return self.score < other.score

    def __gt__(self, other):
        return self.score > other.score

s1 = Student("张三", 85)
s2 = Student("李四", 90)
s3 = Student("王五", 85)

print(s1 == s2)  # False
print(s1 == s3)  # True
print(s1 < s2)   # True
print(s1 > s2)   # False
```

### 5.3 容器方法

```python
class MyList:
    def __init__(self):
        self._items = []

    def __len__(self):
        return len(self._items)

    def __getitem__(self, index):
        return self._items[index]

    def __setitem__(self, index, value):
        self._items[index] = value

    def __delitem__(self, index):
        del self._items[index]

    def __contains__(self, item):
        return item in self._items

    def __iter__(self):
        return iter(self._items)

    def append(self, item):
        self._items.append(item)

# 使用容器方法
my_list = MyList()
my_list.append(1)
my_list.append(2)
my_list.append(3)

print(len(my_list))      # 3
print(my_list[0])        # 1
print(2 in my_list)      # True

for item in my_list:
    print(item)          # 1, 2, 3
```

### 5.4 算术运算方法

```python
class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        return Complex(self.real + other.real, self.imag + other.imag)

    def __sub__(self, other):
        return Complex(self.real - other.real, self.imag - other.imag)

    def __mul__(self, other):
        real = self.real * other.real - self.imag * other.imag
        imag = self.real * other.imag + self.imag * other.real
        return Complex(real, imag)

    def __str__(self):
        return f"{self.real} + {self.imag}i"

c1 = Complex(1, 2)
c2 = Complex(3, 4)
print(c1 + c2)  # 4 + 6i
print(c1 - c2)  # -2 + -2i
print(c1 * c2)  # -5 + 10i
```

### 5.5 实际应用场景

```python
class Vector:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y, self.z - other.z)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar, self.z * scalar)

    def __truediv__(self, scalar):
        return Vector(self.x / scalar, self.y / scalar, self.z / scalar)

    def __len__(self):
        return int((self.x**2 + self.y**2 + self.z**2) ** 0.5)

    def __str__(self):
        return f"Vector({self.x}, {self.y}, {self.z})"

# 向量运算
v1 = Vector(1, 2, 3)
v2 = Vector(4, 5, 6)

print(v1 + v2)     # Vector(5, 7, 9)
print(v1 - v2)     # Vector(-3, -3, -3)
print(v1 * 2)      # Vector(2, 4, 6)
print(v1 / 2)      # Vector(0.5, 1.0, 1.5)
print(len(v1))     # 3
```

## 六、设计模式应用

### 6.1 单例模式

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True
```

### 6.2 工厂模式

```python
class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError("未知的动物类型")

class Dog:
    def speak(self):
        print("汪汪叫")

class Cat:
    def speak(self):
        print("喵喵叫")

# 使用工厂
dog = AnimalFactory.create_animal("dog")
dog.speak()

cat = AnimalFactory.create_animal("cat")
cat.speak()
```

### 6.3 观察者模式

```python
class Subject:
    def __init__(self):
        self._observers = []

    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self, message):
        for observer in self._observers:
            observer.update(message)

class Observer:
    def update(self, message):
        print(f"收到消息：{message}")

# 使用观察者模式
subject = Subject()
observer1 = Observer()
observer2 = Observer()

subject.attach(observer1)
subject.attach(observer2)

subject.notify("新消息来了")
```

## 七、面试常考题

### 7.1 类属性与实例属性的区别

**问题：类属性和实例属性有什么区别？**

**答案：**
| 特性 | 类属性 | 实例属性 |
|------|--------|----------|
| 定义位置 | 类内部，方法外部 | __init__ 方法中 |
| 共享性 | 所有实例共享 | 每个实例独立 |
| 访问方式 | 类名或实例访问 | 实例访问 |
| 修改影响 | 影响所有实例 | 只影响当前实例 |

```python
class MyClass:
    class_attr = "类属性"

    def __init__(self):
        self.instance_attr = "实例属性"

obj1 = MyClass()
obj2 = MyClass()

print(obj1.class_attr)      # 类属性
print(obj1.instance_attr)   # 实例属性
```

### 7.2 方法类型及其区别

**问题：实例方法、类方法和静态方法有什么区别？**

**答案：**
| 方法类型 | 参数 | 访问 | 用途 |
|---------|------|------|------|
| 实例方法 | self | 实例属性和方法 | 操作实例数据 |
| 类方法 | cls | 类属性和方法 | 操作类数据 |
| 静态方法 | 无 | 无 | 工具函数 |

```python
class MyClass:
    def instance_method(self):
        print("实例方法")

    @classmethod
    def class_method(cls):
        print("类方法")

    @staticmethod
    def static_method():
        print("静态方法")
```

### 7.3 继承与组合的选择

**问题：什么时候使用继承，什么时候使用组合？**

**答案：**
- **继承**：is-a 关系（子类是父类的一种）
- **组合**：has-a 关系（对象包含另一个对象）

```python
# 继承：is-a
class Animal:
    pass

class Dog(Animal):  # Dog is an Animal
    pass

# 组合：has-a
class Engine:
    pass

class Car:
    def __init__(self):
        self.engine = Engine()  # Car has an Engine
```

### 7.4 多态的实现方式

**问题：Python 中如何实现多态？**

**答案：**
1. 方法重写
2. 鸭子类型
3. 抽象基类

```python
# 方法重写
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        print("汪汪叫")

# 鸭子类型
def make_speak(animal):
    animal.speak()

dog = Dog()
make_speak(dog)
```

## 八、总结

### 8.1 关键要点

1. **类与对象**：类是模板，对象是实例
2. **封装**：隐藏实现细节，提供接口
3. **继承**：代码复用，建立层次结构
4. **多态**：同一接口，不同实现
5. **特殊方法**：自定义对象行为
6. **设计模式**：解决常见设计问题

### 8.2 最佳实践

1. 优先使用组合而非继承
2. 遵循单一职责原则
3. 使用属性装饰器控制访问
4. 合理使用抽象基类
5. 注意方法解析顺序（MRO）
6. 保持类和方法的简洁

### 8.3 学习建议

1. 理解面向对象的核心概念
2. 多练习设计模式的应用
3. 注意代码的可读性和可维护性
4. 学习 Python 的特殊方法
5. 理解继承和组合的适用场景
6. 掌握多态的实现方式
