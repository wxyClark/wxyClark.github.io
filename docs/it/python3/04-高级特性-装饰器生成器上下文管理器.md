# Python 高级特性：装饰器、生成器与上下文管理器

## 一、装饰器

### 1.1 装饰器基础

```python
# 基本装饰器
def my_decorator(func):
    def wrapper():
        print("函数执行前")
        func()
        print("函数执行后")
    return wrapper

@my_decorator
def say_hello():
    print("Hello, World!")

say_hello()
# 输出：
# 函数执行前
# Hello, World!
# 函数执行后
```

### 1.2 带参数的装饰器

```python
# 装饰器包装带参数的函数
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"调用函数：{func.__name__}")
        print(f"参数：args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"返回值：{result}")
        return result
    return wrapper

@log_decorator
def add(a, b):
    return a + b

result = add(3, 5)
# 输出：
# 调用函数：add
# 参数：args=(3, 5), kwargs={}
# 返回值：8
```

### 1.3 带参数的装饰器工厂

```python
# 装饰器工厂
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("张三")
# 输出：
# Hello, 张三!
# Hello, 张三!
# Hello, 张三!
```

### 1.4 保留原函数信息

```python
from functools import wraps

def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@decorator
def add(a, b):
    """加法函数"""
    return a + b

print(add.__name__)  # add
print(add.__doc__)   # 加法函数
```

### 1.5 类装饰器

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"函数 {self.func.__name__} 被调用了 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()  # 函数 say_hello 被调用了 1 次
say_hello()  # 函数 say_hello 被调用了 2 次
say_hello()  # 函数 say_hello 被调用了 3 次
```

### 1.6 实际应用场景

```python
# 计时装饰器
import time
from functools import wraps

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} 执行时间：{end_time - start_time:.4f} 秒")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "完成"

print(slow_function())

# 缓存装饰器
def memoize(func):
    cache = {}

    @wraps(func)
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

@memoize
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(100))  # 快速计算

# 权限验证装饰器
def require_permission(permission):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            user_permissions = kwargs.get('permissions', [])
            if permission in user_permissions:
                return func(*args, **kwargs)
            else:
                raise PermissionError(f"需要 {permission} 权限")
        return wrapper
    return decorator

@require_permission("admin")
def delete_user(user_id):
    print(f"删除用户 {user_id}")

try:
    delete_user(1, permissions=["user"])
except PermissionError as e:
    print(e)  # 需要 admin 权限
```

## 二、生成器

### 2.1 生成器函数

```python
# 基本生成器
def count_down(n):
    while n > 0:
        yield n
        n -= 1

for num in count_down(5):
    print(num)
# 输出：5, 4, 3, 2, 1
```

### 2.2 生成器表达式

```python
# 生成器表达式（类似列表推导式）
squares = (x**2 for x in range(5))
print(list(squares))  # [0, 1, 4, 9, 16]

# 内存节省
# 列表推导式：一次性生成所有元素
list_comp = [x**2 for x in range(1000000)]

# 生成器表达式：按需生成元素
gen_comp = (x**2 for x in range(1000000))
```

### 2.3 生成器方法

```python
def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()

# next() 获取下一个值
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3

# send() 发送值到生成器
def interactive_generator():
    received = yield "开始"
    while True:
        received = yield f"收到：{received}"

gen = interactive_generator()
print(next(gen))           # 开始
print(gen.send("你好"))    # 收到：你好
print(gen.send("世界"))    # 收到：世界

# throw() 抛出异常
def generator_with_error():
    try:
        yield 1
        yield 2
        yield 3
    except ValueError:
        print("捕获到 ValueError")
        yield 4

gen = generator_with_error()
print(next(gen))  # 1
print(gen.throw(ValueError))  # 捕获到 ValueError，然后返回 4
```

### 2.4 yield from 语法

```python
def sub_generator():
    yield 1
    yield 2

def main_generator():
    yield from sub_generator()
    yield 3
    yield 4

for num in main_generator():
    print(num)
# 输出：1, 2, 3, 4
```

### 2.5 实际应用场景

```python
# 斐波那契数列生成器
def fibonacci_generator(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fibonacci_generator(10):
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34

# 无限序列生成器
def infinite_counter():
    count = 0
    while True:
        yield count
        count += 1

counter = infinite_counter()
print(next(counter))  # 0
print(next(counter))  # 1
print(next(counter))  # 2

# 读取大文件
def read_large_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            yield line.strip()

# 使用生成器逐行处理大文件
# for line in read_large_file('large_file.txt'):
#     process_line(line)

# 数据流处理
def data_pipeline(data):
    # 过滤
    data = (x for x in data if x > 0)
    # 转换
    data = (x ** 2 for x in data)
    # 求和
    return sum(data)

numbers = [-1, 2, -3, 4, -5, 6]
result = data_pipeline(numbers)
print(result)  # 56 (2² + 4² + 6²)
```

## 三、迭代器

### 3.1 迭代器协议

```python
# 自定义迭代器
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

my_iter = MyIterator([1, 2, 3, 4, 5])
for num in my_iter:
    print(num)
# 输出：1, 2, 3, 4, 5
```

### 3.2 可迭代对象与迭代器

```python
# 可迭代对象（实现 __iter__ 方法）
class MyIterable:
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        return MyIterator(self.data)

class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

my_iterable = MyIterable([1, 2, 3])
for num in my_iterable:
    print(num)
```

### 3.3 实际应用场景

```python
# 自定义范围迭代器
class Range:
    def __init__(self, start, end=None, step=1):
        if end is None:
            start, end = 0, start
        self.start = start
        self.end = end
        self.step = step

    def __iter__(self):
        return RangeIterator(self.start, self.end, self.step)

class RangeIterator:
    def __init__(self, start, end, step):
        self.current = start
        self.end = end
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.end:
            raise StopIteration
        value = self.current
        self.current += self.step
        return value

for i in Range(5):
    print(i)  # 0, 1, 2, 3, 4
```

## 四、上下文管理器

### 4.1 基本上下文管理器

```python
# 使用 with 语句
with open('file.txt', 'w', encoding='utf-8') as f:
    f.write('Hello, World!')

# 文件自动关闭，无需手动调用 f.close()
```

### 4.2 自定义上下文管理器

```python
# 使用类实现上下文管理器
class MyContextManager:
    def __enter__(self):
        print("进入上下文")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("退出上下文")
        if exc_type:
            print(f"发生异常：{exc_val}")
        return True  # 抑制异常

with MyContextManager():
    print("执行代码块")
    # raise ValueError("测试异常")
# 输出：
# 进入上下文
# 执行代码块
# 退出上下文
```

### 4.3 contextlib 模块

```python
from contextlib import contextmanager

# 使用装饰器创建上下文管理器
@contextmanager
def my_context():
    print("进入上下文")
    try:
        yield "资源"
    finally:
        print("清理资源")

with my_context() as resource:
    print(f"使用资源：{resource}")
# 输出：
# 进入上下文
# 使用资源：资源
# 清理资源
```

### 4.4 实际应用场景

```python
# 计时上下文管理器
import time
from contextlib import contextmanager

@contextmanager
def timer(name):
    start = time.time()
    yield
    end = time.time()
    print(f"{name} 耗时：{end - start:.4f} 秒")

with timer("数据处理"):
    time.sleep(1)
    print("处理数据中...")
# 输出：
# 处理数据中...
# 数据处理 耗时：1.0000 秒

# 数据库连接上下文管理器
class DatabaseConnection:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connection = None

    def connect(self):
        print(f"连接到数据库 {self.host}:{self.port}")
        self.connection = f"Connection to {self.host}:{self.port}"

    def disconnect(self):
        print("断开数据库连接")
        self.connection = None

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()

with DatabaseConnection("localhost", 5432) as db:
    print(f"使用连接：{db.connection}")
# 输出：
# 连接到数据库 localhost:5432
# 使用连接：Connection to localhost:5432
# 断开数据库连接

# 临时改变目录
import os
from contextlib import contextmanager

@contextmanager
def change_directory(new_dir):
    old_dir = os.getcwd()
    os.chdir(new_dir)
    try:
        yield
    finally:
        os.chdir(old_dir)

with change_directory("/tmp"):
    print(f"当前目录：{os.getcwd()}")
print(f"当前目录：{os.getcwd()}")
```

## 五、高级特性组合应用

### 5.1 装饰器与生成器结合

```python
# 缓存生成器结果
def cache_generator(func):
    cache = []

    def wrapper(*args, **kwargs):
        if not cache:
            for item in func(*args, **kwargs):
                cache.append(item)
        return iter(cache)

    return wrapper

@cache_generator
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fibonacci(10):
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34
```

### 5.2 上下文管理器与装饰器结合

```python
# 使用上下文管理器的装饰器
from contextlib import contextmanager

@contextmanager
def transaction():
    print("开始事务")
    try:
        yield
        print("提交事务")
    except Exception as e:
        print(f"回滚事务：{e}")
        raise

def with_transaction(func):
    def wrapper(*args, **kwargs):
        with transaction():
            return func(*args, **kwargs)
    return wrapper

@with_transaction
def transfer_money(amount):
    print(f"转账 {amount} 元")
    # raise ValueError("余额不足")

transfer_money(1000)
# 输出：
# 开始事务
# 转账 1000 元
# 提交事务
```

### 5.3 实际项目应用

```python
# 日志记录装饰器
import logging
from functools import wraps
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def log_execution(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = datetime.now()
        logger.info(f"开始执行 {func.__name__}")
        try:
            result = func(*args, **kwargs)
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            logger.info(f"{func.__name__} 执行成功，耗时 {duration:.2f} 秒")
            return result
        except Exception as e:
            logger.error(f"{func.__name__} 执行失败：{e}")
            raise
    return wrapper

@log_execution
def process_data(data):
    time.sleep(1)
    return len(data)

result = process_data([1, 2, 3, 4, 5])
```

## 六、面试常考题

### 6.1 装饰器的执行顺序

**问题：多个装饰器的执行顺序是什么？**

**答案：**
装饰器从下往上执行，函数调用从上往下执行。

```python
def decorator1(func):
    def wrapper():
        print("装饰器1")
        func()
    return wrapper

def decorator2(func):
    def wrapper():
        print("装饰器2")
        func()
    return wrapper

@decorator1
@decorator2
def say_hello():
    print("Hello")

say_hello()
# 输出：
# 装饰器1
# 装饰器2
# Hello
```

### 6.2 生成器与迭代器的区别

**问题：生成器和迭代器有什么区别？**

**答案：**
| 特性 | 生成器 | 迭代器 |
|------|--------|--------|
| 实现方式 | 使用 yield 关键字 | 实现 __iter__ 和 __next__ |
| 代码简洁性 | 更简洁 | 较复杂 |
| 状态保存 | 自动保存 | 手动管理 |
| 性能 | 通常更好 | 取决于实现 |

```python
# 生成器
def my_generator():
    yield 1
    yield 2

# 迭代器
class MyIterator:
    def __init__(self):
        self.data = [1, 2]
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value
```

### 6.3 上下文管理器的应用场景

**问题：上下文管理器适用于哪些场景？**

**答案：**
1. 资源管理（文件、数据库连接、网络连接）
2. 状态管理（临时改变环境）
3. 异常处理（自动清理资源）
4. 计时和性能监控

```python
# 资源管理
with open('file.txt') as f:
    data = f.read()

# 状态管理
with change_directory('/tmp'):
    process_files()

# 异常处理
with transaction():
    database_operation()
```

### 6.4 yield 和 return 的区别

**问题：yield 和 return 有什么区别？**

**答案：**
| 特性 | yield | return |
|------|-------|--------|
| 函数类型 | 生成器函数 | 普通函数 |
| 返回值 | 多次返回 | 一次返回 |
| 执行方式 | 暂停和恢复 | 立即结束 |
| 内存使用 | 节省内存 | 占用较多内存 |

```python
# yield
def generator():
    yield 1
    yield 2

# return
def normal_function():
    return 1
    return 2  # 不会执行
```

## 七、总结

### 7.1 关键要点

1. **装饰器**：在不修改函数代码的情况下增强功能
2. **生成器**：惰性求值，节省内存
3. **迭代器**：实现迭代协议，支持 for 循环
4. **上下文管理器**：自动管理资源，确保清理
5. **组合应用**：多种特性结合解决复杂问题

### 7.2 最佳实践

1. 使用 functools.wraps 保留原函数信息
2. 生成器适合处理大数据集
3. 上下文管理器用于资源管理
4. 装饰器用于横切关注点（日志、计时、缓存）
5. 注意异常处理和资源清理
6. 合理使用生成器表达式

### 7.3 学习建议

1. 理解装饰器的执行顺序
2. 掌握生成器的惰性求值特性
3. 学习上下文管理器的实现方式
4. 练习多种特性的组合使用
5. 关注性能优化和内存管理
6. 多看优秀代码库的实现
