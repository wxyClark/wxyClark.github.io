# Python 异常处理与调试

## 一、异常基础

### 1.1 异常类型

```python
# 常见异常类型
print(10 / 0)  # ZeroDivisionError: division by zero

print(int("abc"))  # ValueError: invalid literal for int()

print([1, 2, 3][10])  # IndexError: list index out of range

print({"name": "张三"}["age"])  # KeyError: 'age'

print(open("nonexistent.txt"))  # FileNotFoundError
```

### 1.2 异常层次结构

```
BaseException
 ├── SystemExit
 ├── KeyboardInterrupt
 ├── GeneratorExit
 ├── Exception
      ├── StopIteration
      ├── ArithmeticError
      │    ├── FloatingPointError
      │    ├── OverflowError
      │    └── ZeroDivisionError
      ├── AssertionError
      ├── AttributeError
      ├── BufferError
      ├── EOFError
      ├── ImportError
      ├── LookupError
      │    ├── IndexError
      │    └── KeyError
      ├── MemoryError
      ├── NameError
      ├── OSError
      │    ├── FileNotFoundError
      │    └── PermissionError
      ├── RuntimeError
      ├── SyntaxError
      ├── TypeError
      └── ValueError
```

## 二、异常处理

### 2.1 try-except 语句

```python
# 基本异常处理
try:
    result = 10 / 0
except ZeroDivisionError:
    print("除数不能为零")

# 捕获多个异常
try:
    num = int(input("请输入数字："))
    result = 10 / num
except (ValueError, ZeroDivisionError) as e:
    print(f"发生错误：{e}")

# 捕获所有异常
try:
    result = 10 / 0
except Exception as e:
    print(f"发生异常：{type(e).__name__}: {e}")
```

### 2.2 try-except-else-finally

```python
# 完整的异常处理结构
try:
    file = open('test.txt', 'r', encoding='utf-8')
    content = file.read()
except FileNotFoundError:
    print("文件不存在")
except PermissionError:
    print("没有权限访问文件")
else:
    print("文件读取成功")
    print(f"内容：{content}")
finally:
    if 'file' in locals():
        file.close()
    print("清理资源")
```

### 2.3 异常信息获取

```python
# 获取异常信息
try:
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"异常类型：{type(e)}")
    print(f"异常消息：{e}")
    print(f"异常参数：{e.args}")

# 使用 traceback 获取详细信息
import traceback

try:
    result = 10 / 0
except ZeroDivisionError:
    traceback.print_exc()
```

### 2.4 实际应用场景

```python
# 文件操作异常处理
def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        print(f"文件 {filename} 不存在")
        return None
    except PermissionError:
        print(f"没有权限访问文件 {filename}")
        return None
    except UnicodeDecodeError:
        print(f"文件 {filename} 编码错误")
        return None

# 数据验证异常处理
def validate_user_data(data):
    try:
        if not isinstance(data, dict):
            raise TypeError("数据必须是字典类型")

        if 'name' not in data:
            raise ValueError("缺少 name 字段")

        if not isinstance(data['age'], int):
            raise TypeError("age 必须是整数")

        if data['age'] < 0 or data['age'] > 150:
            raise ValueError("age 必须在 0-150 之间")

        return True

    except (TypeError, ValueError) as e:
        print(f"数据验证失败：{e}")
        return False

# 网络请求异常处理
import requests

def fetch_url(url):
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.Timeout:
        print("请求超时")
        return None
    except requests.exceptions.ConnectionError:
        print("连接错误")
        return None
    except requests.exceptions.HTTPError as e:
        print(f"HTTP 错误：{e}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"请求异常：{e}")
        return None
```

## 三、自定义异常

### 3.1 创建自定义异常

```python
# 自定义异常类
class CustomError(Exception):
    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

class ValidationError(CustomError):
    pass

class AuthenticationError(CustomError):
    pass

# 使用自定义异常
def validate_age(age):
    if age < 0:
        raise ValidationError("年龄不能为负数")
    if age > 150:
        raise ValidationError("年龄不能超过150岁")
    return True

try:
    validate_age(-5)
except ValidationError as e:
    print(f"验证失败：{e.message}")
```

### 3.2 异常链

```python
# 异常链（使用 raise from）
class DataProcessingError(Exception):
    pass

def process_data(data):
    try:
        result = int(data)
    except ValueError as e:
        raise DataProcessingError("数据处理失败") from e

try:
    process_data("abc")
except DataProcessingError as e:
    print(f"主异常：{e}")
    print(f"原始异常：{e.__cause__}")
```

### 3.3 实际应用场景

```python
# 业务异常处理
class BusinessError(Exception):
    def __init__(self, code, message):
        self.code = code
        self.message = message
        super().__init__(f"[{code}] {message}")

class InsufficientBalanceError(BusinessError):
    def __init__(self, balance, amount):
        super().__init__(
            "INSUFFICIENT_BALANCE",
            f"余额不足，当前余额：{balance}，需要金额：{amount}"
        )
        self.balance = balance
        self.amount = amount

class AccountNotFoundError(BusinessError):
    def __init__(self, account_id):
        super().__init__(
            "ACCOUNT_NOT_FOUND",
            f"账户不存在：{account_id}"
        )

# 银行账户系统
class BankAccount:
    def __init__(self, account_id, balance=0):
        self.account_id = account_id
        self.balance = balance

    def withdraw(self, amount):
        if amount > self.balance:
            raise InsufficientBalanceError(self.balance, amount)
        self.balance -= amount
        return self.balance

    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("存款金额必须大于0")
        self.balance += amount
        return self.balance

# 使用业务异常
accounts = {
    "001": BankAccount("001", 1000),
    "002": BankAccount("002", 500)
}

def transfer(from_id, to_id, amount):
    try:
        if from_id not in accounts:
            raise AccountNotFoundError(from_id)
        if to_id not in accounts:
            raise AccountNotFoundError(to_id)

        accounts[from_id].withdraw(amount)
        accounts[to_id].deposit(amount)

        print(f"转账成功：{amount} 元从 {from_id} 转到 {to_id}")

    except BusinessError as e:
        print(f"业务错误：{e.message}")
    except Exception as e:
        print(f"系统错误：{e}")

transfer("001", "002", 200)
transfer("001", "002", 2000)  # 余额不足
transfer("003", "002", 100)   # 账户不存在
```

## 四、调试技巧

### 4.1 print 调试

```python
# 简单的 print 调试
def calculate(a, b):
    print(f"输入：a={a}, b={b}")
    result = a + b
    print(f"结果：{result}")
    return result

calculate(10, 20)

# 使用 f-string 格式化
name = "张三"
age = 25
print(f"姓名：{name}，年龄：{age}")
```

### 4.2 logging 调试

```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

def process_data(data):
    logger.debug(f"开始处理数据：{data}")

    try:
        result = int(data)
        logger.info(f"数据处理成功：{result}")
        return result
    except ValueError as e:
        logger.error(f"数据处理失败：{e}")
        raise

process_data("123")
process_data("abc")
```

### 4.3 pdb 调试器

```python
# 使用 pdb 调试
import pdb

def complex_function(x, y):
    pdb.set_trace()  # 设置断点
    result = x * y + 10
    intermediate = result / 2
    final = intermediate ** 2
    return final

# 运行时使用命令：
# n (next): 执行下一行
# s (step): 进入函数
# c (continue): 继续执行
# p (print): 打印变量
# q (quit): 退出调试

# complex_function(5, 3)
```

### 4.4 assert 语句

```python
# 使用 assert 进行调试
def divide(a, b):
    assert b != 0, "除数不能为零"
    return a / b

def validate_age(age):
    assert isinstance(age, int), "年龄必须是整数"
    assert 0 <= age <= 150, "年龄必须在 0-150 之间"
    return age

# 在生产环境中可以禁用 assert
# python -O script.py  # -O 参数禁用 assert
```

## 五、性能分析

### 5.1 timeit 模块

```python
import timeit

# 测量代码执行时间
code = """
sum(range(1000))
"""

execution_time = timeit.timeit(code, number=1000)
print(f"执行时间：{execution_time:.4f} 秒")

# 测量函数执行时间
def test_function():
    return sum(range(1000))

time_taken = timeit.timeit(test_function, number=1000)
print(f"函数执行时间：{time_taken:.4f} 秒")
```

### 5.2 cProfile 模块

```python
import cProfile

def slow_function():
    total = 0
    for i in range(1000000):
        total += i
    return total

def fast_function():
    return sum(range(1000000))

# 性能分析
cProfile.run('slow_function()')
cProfile.run('fast_function()')
```

### 5.3 memory_profiler

```python
# 需要安装：pip install memory_profiler
from memory_profiler import profile

@profile
def memory_intensive_function():
    data = []
    for i in range(100000):
        data.append(i)
    return data

# memory_intensive_function()
```

## 六、单元测试

### 6.1 unittest 模块

```python
import unittest

def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

class TestMathFunctions(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)

    def test_divide(self):
        self.assertEqual(divide(10, 2), 5)
        self.assertEqual(divide(7, 2), 3.5)

    def test_divide_by_zero(self):
        with self.assertRaises(ValueError):
            divide(10, 0)

if __name__ == '__main__':
    unittest.main()
```

### 6.2 pytest 框架

```python
# 需要安装：pip install pytest
import pytest

def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0

def test_divide():
    assert divide(10, 2) == 5
    assert divide(7, 2) == 3.5

def test_divide_by_zero():
    with pytest.raises(ValueError):
        divide(10, 0)

# 运行测试：pytest test_file.py
```

## 七、面试常考题

### 7.1 try-except 的执行顺序

**问题：try-except-else-finally 的执行顺序是什么？**

**答案：**
1. try 块执行
2. 如果发生异常，执行对应的 except 块
3. 如果没有异常，执行 else 块
4. 无论是否异常，都执行 finally 块

```python
try:
    print("try")
    result = 10 / 0
except ZeroDivisionError:
    print("except")
else:
    print("else")
finally:
    print("finally")

# 输出：
# try
# except
# finally
```

### 7.2 异常处理的最佳实践

**问题：异常处理的最佳实践有哪些？**

**答案：**
1. 只捕获预期的异常
2. 避免捕获所有异常（except:）
3. 使用 finally 清理资源
4. 提供有意义的错误信息
5. 使用上下文管理器管理资源
6. 不要在异常处理中吞掉异常

```python
# 好的做法
try:
    file = open('data.txt', 'r')
    data = file.read()
except FileNotFoundError:
    print("文件不存在")
finally:
    file.close()

# 不好的做法
try:
    file = open('data.txt', 'r')
    data = file.read()
except:  # 捕获所有异常
    pass  # 吞掉异常
```

### 7.3 自定义异常的使用场景

**问题：什么时候应该使用自定义异常？**

**答案：**
1. 业务逻辑错误
2. 需要传递额外信息
3. 需要区分不同类型的错误
4. 需要特定的错误处理逻辑

```python
class InsufficientBalanceError(Exception):
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        super().__init__(f"余额不足：{balance}，需要：{amount}")

def withdraw(balance, amount):
    if amount > balance:
        raise InsufficientBalanceError(balance, amount)
    return balance - amount
```

### 7.4 调试技巧

**问题：常用的调试技巧有哪些？**

**答案：**
1. print 调试：简单直接
2. logging 调试：结构化日志
3. pdb 调试器：交互式调试
4. IDE 调试器：图形化调试
5. 单元测试：验证代码逻辑
6. 性能分析：找出性能瓶颈

```python
# print 调试
print(f"变量值：{variable}")

# logging 调试
logger.debug(f"调试信息：{variable}")

# pdb 调试
import pdb
pdb.set_trace()

# IDE 调试
# 在 IDE 中设置断点
```

## 八、总结

### 8.1 关键要点

1. **异常类型**：了解常见异常及其层次结构
2. **异常处理**：try-except-else-finally 结构
3. **自定义异常**：创建业务相关的异常类
4. **调试技巧**：print、logging、pdb
5. **性能分析**：timeit、cProfile
6. **单元测试**：unittest、pytest

### 8.2 最佳实践

1. 只捕获预期的异常
2. 提供有意义的错误信息
3. 使用 finally 清理资源
4. 优先使用上下文管理器
5. 合理使用自定义异常
6. 编写单元测试验证代码
7. 使用 logging 而非 print

### 8.3 学习建议

1. 理解异常层次结构
2. 掌握异常处理模式
3. 学习调试工具的使用
4. 编写完善的单元测试
5. 关注性能优化技巧
6. 阅读优秀代码的异常处理
7. 实践调试和测试技巧
