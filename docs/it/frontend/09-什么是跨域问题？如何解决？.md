# 什么是跨域问题？如何解决？

## 概要回答

跨域问题源于浏览器的同源策略，即协议、域名、端口任一不同就会被浏览器阻止。这是为了安全考虑，防止恶意网站窃取数据。解决跨域问题的方法包括：CORS(跨域资源共享)、JSONP、代理服务器、Nginx反向代理、postMessage等。其中CORS是最常用和推荐的解决方案。

## 深度解析

### 同源策略和跨域问题

同源策略是浏览器的重要安全机制，它限制了一个源(origin)的文档或脚本如何与另一个源的资源进行交互。同源需要满足以下三个条件：
1. **协议相同**：http vs https
2. **域名相同**：example.com vs another.com
3. **端口相同**：80 vs 8080

当不满足以上任一条件时，就构成了跨域请求。

### 跨域问题的表现

当发生跨域请求时，浏览器控制台通常会出现类似的错误信息：
```
Access to fetch at 'http://api.example.com/data' from origin 'http://localhost:3000' 
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present 
on the requested resource.
```

### 跨域问题的原理

浏览器在发送跨域请求时会先发送一个预检请求(OPTIONS)，询问服务器是否允许跨域访问。如果服务器没有正确配置CORS头，浏览器就会阻止请求。

## 示例代码

### 同源策略示例

```javascript
// 同源策略示例
// 当前页面: http://example.com:8080

// 以下请求属于同源
fetch('http://example.com:8080/api/data'); // ✓ 同源

// 以下请求属于跨域
fetch('https://example.com:8080/api/data');    // ✗ 协议不同
fetch('http://www.example.com:8080/api/data'); // ✗ 域名不同
fetch('http://example.com:8081/api/data');     // ✗ 端口不同
```

### CORS(跨域资源共享)解决方案

```javascript
// 客户端代码
async function fetchData() {
    try {
        const response = await fetch('http://api.example.com/data', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer token'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(data);
        } else {
            console.error('Request failed:', response.status);
        }
    } catch (error) {
        console.error('Network error:', error);
    }
}

// 简单请求示例(不会触发预检请求)
fetch('http://api.example.com/data', {
    method: 'GET',
    headers: {
        'Content-Type': 'text/plain' // 简单请求允许的Content-Type
    }
});

// 复杂请求示例(会触发预检请求)
fetch('http://api.example.com/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json', // 复杂请求
        'X-Custom-Header': 'value'          // 自定义头部
    },
    body: JSON.stringify({ key: 'value' })
});
```

```javascript
// 服务端CORS配置(Node.js Express示例)
const express = require('express');
const cors = require('cors');
const app = express();

// 方法1: 使用cors中间件(推荐)
app.use(cors({
    origin: ['http://localhost:3000', 'https://yourdomain.com'], // 允许的源
    credentials: true, // 是否允许携带凭证(cookie等)
    optionsSuccessStatus: 200 // 预检请求的成功状态码
}));

// 方法2: 手动设置CORS头
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
    res.header('Access-Control-Allow-Credentials', 'true');
    
    // 处理预检请求
    if (req.method === 'OPTIONS') {
        res.sendStatus(200);
    } else {
        next();
    }
});

app.get('/data', (req, res) => {
    res.json({ message: 'Hello from API' });
});

app.listen(4000);
```

### JSONP解决方案

```javascript
// JSONP实现(仅支持GET请求)
function jsonp(url, callback) {
    // 创建唯一的回调函数名
    const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
    
    // 在全局作用域定义回调函数
    window[callbackName] = function(data) {
        // 清理：删除回调函数和script标签
        delete window[callbackName];
        document.body.removeChild(script);
        // 执行用户回调
        callback(data);
    };
    
    // 创建script标签
    const script = document.createElement('script');
    script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + callbackName;
    document.body.appendChild(script);
}

// 使用示例
jsonp('http://api.example.com/data', function(data) {
    console.log('JSONP data:', data);
});
```

```javascript
// 服务端JSONP支持
app.get('/data', (req, res) => {
    const callback = req.query.callback;
    const data = { message: 'Hello from JSONP API' };
    
    if (callback) {
        // JSONP响应
        res.send(`${callback}(${JSON.stringify(data)})`);
    } else {
        // 普通JSON响应
        res.json(data);
    }
});
```

### 代理服务器解决方案

```javascript
// Webpack开发服务器代理配置
// webpack.config.js
module.exports = {
    devServer: {
        proxy: {
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true,
                pathRewrite: {
                    '^/api': '' // 重写路径
                }
            }
        }
    }
};

// Vite代理配置
// vite.config.js
export default {
    server: {
        proxy: {
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true,
                rewrite: (path) => path.replace(/^\/api/, '')
            }
        }
    }
};
```

```javascript
// Node.js代理服务器实现
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const app = express();

// 代理API请求
app.use('/api', createProxyMiddleware({
    target: 'http://localhost:3000',
    changeOrigin: true,
    pathRewrite: {
        '^/api': '' // 移除/api前缀
    }
}));

app.listen(8080);
```

### Nginx反向代理解决方案

```nginx
# nginx.conf
server {
    listen 80;
    server_name example.com;
    
    # 前端静态资源
    location / {
        root /var/www/html;
        index index.html;
        try_files $uri $uri/ =404;
    }
    
    # API代理
    location /api/ {
        proxy_pass http://backend-server:3000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # CORS头设置
        add_header Access-Control-Allow-Origin "http://example.com";
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
        add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
    }
    
    # 处理预检请求
    location ~* ^/api/.*$ {
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "http://example.com";
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
            add_header Access-Control-Max-Age 86400;
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}
```

### postMessage解决方案

```html
<!-- 父页面 (http://parent.com) -->
<!DOCTYPE html>
<html>
<head>
    <title>Parent Page</title>
</head>
<body>
    <iframe id="childFrame" src="http://child.com/child.html"></iframe>
    
    <script>
        // 向iframe发送消息
        const iframe = document.getElementById('childFrame');
        
        // 等待iframe加载完成
        iframe.onload = function() {
            iframe.contentWindow.postMessage(
                { type: 'GREETING', data: 'Hello from parent' },
                'http://child.com'
            );
        };
        
        // 监听来自iframe的消息
        window.addEventListener('message', function(event) {
            // 验证消息来源
            if (event.origin !== 'http://child.com') {
                return;
            }
            
            console.log('Received from child:', event.data);
        });
    </script>
</body>
</html>
```

```html
<!-- 子页面 (http://child.com/child.html) -->
<!DOCTYPE html>
<html>
<head>
    <title>Child Page</title>
</head>
<body>
    <script>
        // 监听来自父页面的消息
        window.addEventListener('message', function(event) {
            // 验证消息来源
            if (event.origin !== 'http://parent.com') {
                return;
            }
            
            console.log('Received from parent:', event.data);
            
            // 向父页面发送回复
            event.source.postMessage(
                { type: 'REPLY', data: 'Hello from child' },
                event.origin
            );
        });
    </script>
</body>
</html>
```

### WebSocket跨域解决方案

```javascript
// WebSocket天然支持跨域
const socket = new WebSocket('ws://api.example.com/socket');

socket.onopen = function(event) {
    console.log('WebSocket connected');
    socket.send('Hello Server');
};

socket.onmessage = function(event) {
    console.log('Message from server:', event.data);
};

socket.onerror = function(error) {
    console.error('WebSocket error:', error);
};

socket.onclose = function(event) {
    console.log('WebSocket closed');
};
```

```javascript
// 服务端WebSocket支持
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws, req) {
    // 获取客户端origin
    const origin = req.headers.origin;
    
    // 验证origin(可选的安全检查)
    if (origin !== 'http://localhost:3000') {
        ws.close();
        return;
    }
    
    ws.on('message', function incoming(message) {
        console.log('Received:', message);
        ws.send('Echo: ' + message);
    });
    
    ws.send('Welcome to WebSocket server');
});
```

### document.domain解决方案

```html
<!-- 主页面 (http://www.example.com) -->
<iframe src="http://sub.example.com/frame.html"></iframe>

<script>
    // 设置document.domain
    document.domain = 'example.com';
    
    // 访问iframe内容
    window.onload = function() {
        const iframe = document.getElementsByTagName('iframe')[0];
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        console.log(iframeDoc.body.innerHTML);
    };
</script>
```

```html
<!-- iframe页面 (http://sub.example.com/frame.html) -->
<script>
    // 设置相同的document.domain
    document.domain = 'example.com';
</script>
```

## 各种解决方案对比

| 解决方案 | 优点 | 缺点 | 适用场景 |
|---------|------|------|---------|
| CORS | 标准化、支持所有HTTP方法 | 需要服务端配合 | 现代Web应用首选 |
| JSONP | 兼容性好、实现简单 | 仅支持GET、安全性较低 | 老旧系统、第三方API |
| 代理服务器 | 开发环境简单、无需修改服务端 | 生产环境需额外配置 | 开发环境、SPA应用 |
| Nginx反向代理 | 性能好、生产环境稳定 | 需要运维配置 | 生产环境 |
| postMessage | 安全、支持iframe通信 | 仅限iframe间通信 | iframe跨域通信 |
| WebSocket | 天然支持跨域、实时通信 | 需要WebSocket服务 | 实时应用 |

## 最佳实践

### 1. 生产环境推荐使用CORS

```javascript
// 生产环境CORS配置
app.use(cors({
    origin: function(origin, callback) {
        // 白名单验证
        const whitelist = [
            'https://yourdomain.com',
            'https://www.yourdomain.com'
        ];
        
        // 允许同源请求和白名单中的源
        if (!origin || whitelist.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true, // 允许携带凭证
    optionsSuccessStatus: 200
}));
```

### 2. 开发环境使用代理

```javascript
// 开发环境代理配置
// vite.config.js
export default {
    server: {
        proxy: {
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true,
                secure: false, // 如果是HTTPS目标
                rewrite: (path) => path.replace(/^\/api/, '/api/v1')
            }
        }
    }
};
```

### 3. 安全考虑

```javascript
// 安全的CORS配置
app.use(cors({
    origin: function(origin, callback) {
        // 检查origin是否存在(直接访问时origin为undefined)
        if (!origin) return callback(null, true);
        
        // 验证origin是否在白名单中
        if (allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true,
    exposedHeaders: ['X-Total-Count'], // 暴露自定义头部
    maxAge: 86400 // 预检请求缓存时间(24小时)
}));
```

## 总结

跨域问题是前端开发中的常见问题，理解其原理和解决方案非常重要：

1. **根本原因**：浏览器的同源策略
2. **主要解决方案**：
   - CORS：最推荐的标准解决方案
   - JSONP：适用于简单GET请求
   - 代理：开发环境常用
   - Nginx反向代理：生产环境稳定方案
3. **安全考虑**：合理配置CORS白名单，避免过度开放
4. **选择建议**：根据具体场景选择合适的解决方案

掌握这些跨域解决方案，能够帮助开发者更好地处理前后端分离项目中的跨域问题。