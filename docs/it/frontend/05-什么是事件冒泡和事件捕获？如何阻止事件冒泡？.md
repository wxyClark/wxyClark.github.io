# 什么是事件冒泡和事件捕获？如何阻止事件冒泡？

## 概要回答

事件冒泡和事件捕获是DOM事件传播的两种机制。事件冒泡是指事件从目标元素开始向外传播到最外层元素；事件捕获是指事件从最外层元素开始向内传播到目标元素。可以通过`stopPropagation()`方法阻止事件冒泡，使用`preventDefault()`方法阻止默认行为。

## 深度解析

### 事件传播机制

当DOM元素上触发事件时，事件会在DOM树中传播，这个过程分为三个阶段：

1. **捕获阶段(Capturing Phase)**：事件从document对象向下传播到目标元素
2. **目标阶段(Target Phase)**：事件到达目标元素
3. **冒泡阶段(Bubbling Phase)**：事件从目标元素向上传播到document对象

### 事件冒泡

事件冒泡是最常见的事件传播方式。当一个元素上的事件被触发时，同样的事件会向上传播到其父元素，一直到根节点。

### 事件捕获

事件捕获是事件冒泡的相反过程。事件从最外层元素开始，逐级向下传播到目标元素。

### 事件传播的可视化表示

```
<div id="outer">
    <div id="inner">
        <button id="btn">Click Me</button>
    </div>
</div>

事件传播路径：
捕获阶段: document -> html -> body -> outer -> inner -> btn
目标阶段: btn
冒泡阶段: btn -> inner -> outer -> body -> html -> document
```

## 示例代码

### 基础事件冒泡示例

```html
<!DOCTYPE html>
<html>
<head>
    <title>事件冒泡示例</title>
</head>
<body>
    <div id="outer" style="padding: 20px; background-color: lightblue;">
        Outer Div
        <div id="inner" style="padding: 20px; background-color: lightcoral;">
            Inner Div
            <button id="btn">Click Me</button>
        </div>
    </div>

    <script>
        // 事件冒泡示例
        document.getElementById('outer').addEventListener('click', function(e) {
            console.log('Outer div clicked (bubble phase)');
        });

        document.getElementById('inner').addEventListener('click', function(e) {
            console.log('Inner div clicked (bubble phase)');
        });

        document.getElementById('btn').addEventListener('click', function(e) {
            console.log('Button clicked (target phase)');
        });

        // 点击按钮时的输出顺序：
        // Button clicked (target phase)
        // Inner div clicked (bubble phase)
        // Outer div clicked (bubble phase)
    </script>
</body>
</html>
```

### 事件捕获示例

```html
<!DOCTYPE html>
<html>
<head>
    <title>事件捕获示例</title>
</head>
<body>
    <div id="outer" style="padding: 20px; background-color: lightblue;">
        Outer Div
        <div id="inner" style="padding: 20px; background-color: lightcoral;">
            Inner Div
            <button id="btn">Click Me</button>
        </div>
    </div>

    <script>
        // 事件捕获示例
        document.getElementById('outer').addEventListener('click', function(e) {
            console.log('Outer div captured');
        }, true); // 第三个参数设为true表示在捕获阶段触发

        document.getElementById('inner').addEventListener('click', function(e) {
            console.log('Inner div captured');
        }, true);

        document.getElementById('btn').addEventListener('click', function(e) {
            console.log('Button clicked (target phase)');
        }, true);

        // 同时添加冒泡阶段的监听器
        document.getElementById('outer').addEventListener('click', function(e) {
            console.log('Outer div bubbled');
        }, false);

        document.getElementById('inner').addEventListener('click', function(e) {
            console.log('Inner div bubbled');
        }, false);

        document.getElementById('btn').addEventListener('click', function(e) {
            console.log('Button clicked (target phase - bubble)');
        }, false);

        // 点击按钮时的输出顺序：
        // Outer div captured
        // Inner div captured
        // Button clicked (target phase)
        // Button clicked (target phase - bubble)
        // Inner div bubbled
        // Outer div bubbled
    </script>
</body>
</html>
```

### 阻止事件冒泡

```html
<!DOCTYPE html>
<html>
<head>
    <title>阻止事件冒泡示例</title>
</head>
<body>
    <div id="outer" style="padding: 20px; background-color: lightblue;">
        Outer Div
        <div id="inner" style="padding: 20px; background-color: lightcoral;">
            Inner Div
            <button id="btn-stop">Stop Bubble</button>
            <button id="btn-continue">Continue Bubble</button>
        </div>
    </div>

    <script>
        // 外层div的点击事件
        document.getElementById('outer').addEventListener('click', function(e) {
            console.log('Outer div clicked');
        });

        // 内层div的点击事件
        document.getElementById('inner').addEventListener('click', function(e) {
            console.log('Inner div clicked');
        });

        // 阻止事件冒泡的按钮
        document.getElementById('btn-stop').addEventListener('click', function(e) {
            console.log('Stop bubble button clicked');
            // 阻止事件冒泡
            e.stopPropagation();
            // 或者使用 e.cancelBubble = true; (IE兼容)
        });

        // 继续事件冒泡的按钮
        document.getElementById('btn-continue').addEventListener('click', function(e) {
            console.log('Continue bubble button clicked');
            // 不阻止事件冒泡，事件会继续向上传播
        });

        // 测试效果：
        // 点击"Stop Bubble"按钮：
        // Stop bubble button clicked
        //
        // 点击"Continue Bubble"按钮：
        // Continue bubble button clicked
        // Inner div clicked
        // Outer div clicked
    </script>
</body>
</html>
```

### 阻止默认行为

```html
<!DOCTYPE html>
<html>
<head>
    <title>阻止默认行为示例</title>
</head>
<body>
    <a href="https://www.google.com" id="link">Google Link</a>
    <form id="form">
        <input type="text" placeholder="Enter something" required>
        <button type="submit">Submit</button>
    </form>

    <script>
        // 阻止链接的默认跳转行为
        document.getElementById('link').addEventListener('click', function(e) {
            e.preventDefault(); // 阻止默认行为
            console.log('Link clicked, but navigation prevented');
            // 可以在这里执行自定义逻辑
        });

        // 阻止表单的默认提交行为
        document.getElementById('form').addEventListener('submit', function(e) {
            e.preventDefault(); // 阻止默认提交
            console.log('Form submission prevented');
            
            // 执行自定义验证和提交逻辑
            const input = this.querySelector('input');
            if (input.value.trim()) {
                console.log('Custom form submission:', input.value);
                // 这里可以执行AJAX提交等操作
            } else {
                console.log('Input is required');
            }
        });
    </script>
</body>
</html>
```

### 事件委托(Event Delegation)

```html
<!DOCTYPE html>
<html>
<head>
    <title>事件委托示例</title>
</head>
<body>
    <ul id="list">
        <li>Item 1</li>
        <li>Item 2</li>
        <li>Item 3</li>
    </ul>
    <button id="addItem">Add Item</button>

    <script>
        // 使用事件委托处理列表项点击
        document.getElementById('list').addEventListener('click', function(e) {
            // 检查点击的目标是否是li元素
            if (e.target.tagName === 'LI') {
                console.log('Clicked item:', e.target.textContent);
                
                // 可以在这里处理点击逻辑
                e.target.style.backgroundColor = 'yellow';
            }
        });

        // 动态添加列表项
        document.getElementById('addItem').addEventListener('click', function() {
            const newItem = document.createElement('li');
            newItem.textContent = `Item ${document.querySelectorAll('#list li').length + 1}`;
            document.getElementById('list').appendChild(newItem);
        });

        // 新添加的列表项也会响应点击事件，因为事件委托是在父元素上处理的
    </script>
</body>
</html>
```

### 现代事件处理API

```javascript
// 现代事件处理API示例

// 添加事件监听器
const button = document.getElementById('myButton');

// 基本用法
button.addEventListener('click', function(e) {
    console.log('Button clicked');
});

// 使用选项对象
button.addEventListener('click', function(e) {
    console.log('Capture phase click');
}, {
    capture: true, // 在捕获阶段触发
    once: true,    // 只执行一次
    passive: false // 是否被动监听（不影响preventDefault）
});

// 移除事件监听器
function handleClick(e) {
    console.log('This handler can be removed');
}

button.addEventListener('click', handleClick);
// 在适当的时候移除监听器
// button.removeEventListener('click', handleClick);

// 获取事件相关信息
button.addEventListener('click', function(e) {
    console.log('Event type:', e.type);
    console.log('Target element:', e.target);
    console.log('Current target:', e.currentTarget);
    console.log('Event phase:', e.eventPhase); // 1=捕获, 2=目标, 3=冒泡
    console.log('Coordinates:', e.clientX, e.clientY);
});
```

### 自定义事件

```javascript
// 创建和派发自定义事件
const myElement = document.getElementById('myElement');

// 监听自定义事件
myElement.addEventListener('customEvent', function(e) {
    console.log('Custom event received:', e.detail);
});

// 创建自定义事件
const customEvent = new CustomEvent('customEvent', {
    detail: { message: 'Hello from custom event' },
    bubbles: true,    // 是否冒泡
    cancelable: true  // 是否可以取消
});

// 派发自定义事件
myElement.dispatchEvent(customEvent);

// 也可以使用更简单的方式创建事件
const simpleEvent = new Event('simpleEvent');
myElement.dispatchEvent(simpleEvent);
```

### 实际应用场景

```javascript
// 实际应用：模态框关闭功能
function setupModal() {
    const modal = document.querySelector('.modal');
    const closeBtn = modal.querySelector('.close-btn');
    const overlay = modal.querySelector('.overlay');
    
    // 点击关闭按钮或遮罩层关闭模态框
    function closeModal(e) {
        if (e.target === closeBtn || e.target === overlay) {
            modal.style.display = 'none';
        }
    }
    
    // 在捕获阶段监听，确保能捕获到所有点击
    modal.addEventListener('click', closeModal, true);
}

// 实际应用：表格行选择
function setupTableRowSelection() {
    const table = document.querySelector('.data-table');
    
    table.addEventListener('click', function(e) {
        // 确保点击的是表格行
        if (e.target.closest('tr') && !e.target.closest('tr').classList.contains('header')) {
            const row = e.target.closest('tr');
            
            // 移除其他行的选中状态
            table.querySelectorAll('tr.selected').forEach(r => r.classList.remove('selected'));
            
            // 添加当前行的选中状态
            row.classList.add('selected');
            
            // 阻止事件继续冒泡（如果需要）
            // e.stopPropagation();
        }
    });
}

// 实际应用：键盘事件处理
function setupKeyboardNavigation() {
    document.addEventListener('keydown', function(e) {
        // 阻止某些按键的默认行为
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            // 处理自定义导航逻辑
            console.log('Custom arrow key handling');
        }
        
        // 全局快捷键
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            console.log('Save shortcut pressed');
        }
    });
}
```

## 阻止事件传播的方法总结

### 1. stopPropagation()

```javascript
element.addEventListener('click', function(e) {
    e.stopPropagation(); // 阻止事件继续传播
});
```

### 2. stopImmediatePropagation()

```javascript
element.addEventListener('click', function(e) {
    e.stopImmediatePropagation(); // 阻止事件继续传播，并阻止同一元素上的其他监听器执行
});

element.addEventListener('click', function(e) {
    // 这个监听器不会执行，因为上面调用了stopImmediatePropagation()
    console.log('This will not be logged');
});
```

### 3. preventDefault()

```javascript
element.addEventListener('click', function(e) {
    e.preventDefault(); // 阻止默认行为，但不影响事件传播
});
```

## 最佳实践

### 1. 合理使用事件委托

```javascript
// 好的做法：使用事件委托处理大量相似元素
document.querySelector('.list-container').addEventListener('click', function(e) {
    if (e.target.classList.contains('list-item')) {
        handleItemClick(e.target);
    }
});

// 避免为每个元素单独添加监听器
// const items = document.querySelectorAll('.list-item');
// items.forEach(item => {
//     item.addEventListener('click', handleItemClick); // 性能较差
// });
```

### 2. 及时移除事件监听器

```javascript
// 在适当的时候移除监听器，避免内存泄漏
function setupComponent() {
    const button = document.getElementById('myButton');
    
    function handleClick() {
        // 处理点击
    }
    
    button.addEventListener('click', handleClick);
    
    // 在组件销毁时移除监听器
    return function destroy() {
        button.removeEventListener('click', handleClick);
    };
}
```

### 3. 正确使用捕获和冒泡

```javascript
// 在需要提前拦截事件时使用捕获阶段
document.addEventListener('click', function(e) {
    // 全局点击拦截器
    if (shouldInterceptClick(e.target)) {
        e.stopPropagation();
    }
}, true); // 捕获阶段
```

## 总结

事件冒泡和事件捕获是DOM事件处理的核心概念：

1. **事件冒泡**：事件从目标元素向上传播到根节点
2. **事件捕获**：事件从根节点向下传播到目标元素
3. **阻止传播**：使用`stopPropagation()`方法阻止事件传播
4. **阻止默认行为**：使用`preventDefault()`方法阻止默认行为
5. **事件委托**：利用事件冒泡机制处理多个相似元素的事件

理解这些概念对于编写高效的前端交互代码非常重要，特别是在处理复杂UI和性能优化时。