# 常见中级前端面试题10道

## 概要回答

在PHP全栈开发的面试中，前端技能也是考察的重点之一。以下是10个常见的中级前端面试题，涵盖了HTML、CSS、JavaScript的核心概念，以及现代前端开发中的重要知识点。

## 深度解析

### 1. JavaScript中的闭包是什么？请举例说明其应用场景

#### 答案解析

闭包是指一个函数能够访问并操作其外部作用域中的变量，即使在其外部函数已经返回之后。闭包由函数以及创建该函数的词法环境组合而成。

#### 示例代码

```javascript
// 闭包示例
function outerFunction(x) {
    return function innerFunction(y) {
        return x + y;
    };
}

const addFive = outerFunction(5);
console.log(addFive(3)); // 输出 8

// 闭包的实际应用场景 - 数据封装和私有变量
function createCounter() {
    let count = 0;
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());  // 2
```

#### 应用场景

1. 数据封装和私有变量模拟
2. 模块模式
3. 回调函数和事件处理
4. 函数工厂

### 2. CSS盒模型的理解及其两种模式的区别

#### 答案解析

CSS盒模型是页面布局的基础，描述了元素如何计算其宽度和高度。每个元素都被视为一个矩形盒子，包含四个部分：内容(content)、内边距(padding)、边框(border)、外边距(margin)。

#### 两种盒模型模式

1. **标准盒模型(W3C模型)**：
   - width/height 指的是内容区域的宽度/高度
   - 盒子总宽度 = width + padding + border + margin

2. **IE盒模型(怪异盒模型)**：
   - width/height 指的是内容区域+padding+border的总和
   - 盒子总宽度 = width + margin

#### 示例代码

```css
/* 标准盒模型 */
.element-standard {
    box-sizing: content-box; /* 默认值 */
    width: 200px;
    padding: 20px;
    border: 10px solid #000;
    margin: 10px;
    /* 实际占用宽度 = 200 + 20*2 + 10*2 + 10*2 = 280px */
}

/* IE盒模型 */
.element-ie {
    box-sizing: border-box;
    width: 200px;
    padding: 20px;
    border: 10px solid #000;
    margin: 10px;
    /* 实际占用宽度 = 200 + 10*2 = 220px (width包含padding和border) */
}
```

### 3. JavaScript中的原型链和继承是如何工作的？

#### 答案解析

JavaScript是一种基于原型的语言，每个对象都有一个内部属性[[Prototype]]指向其原型对象。当试图访问一个对象的属性时，JavaScript会沿着原型链向上查找，直到找到该属性或者到达原型链的顶端(null)。

#### 示例代码

```javascript
// 构造函数和原型
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound.`);
};

function Dog(name, breed) {
    Animal.call(this, name); // 调用父构造函数
    this.breed = breed;
}

// 设置原型链继承
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    console.log(`${this.name} barks.`);
};

// ES6 Class语法（语法糖）
class AnimalES6 {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound.`);
    }
}

class DogES6 extends AnimalES6 {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    bark() {
        console.log(`${this.name} barks.`);
    }
}

const dog = new DogES6('旺财', '金毛');
dog.speak(); // 旺财 makes a sound.
dog.bark();  // 旺财 barks.
```

### 4. 如何理解和使用Promise？它解决了什么问题？

#### 答案解析

Promise是JavaScript中处理异步操作的一种方式，它代表了一个异步操作的最终完成或失败及其结果值。Promise解决了回调地狱(callback hell)的问题，使异步代码更加清晰和易于管理。

#### Promise的三种状态

1. Pending(待定)：初始状态，既没有被兑现，也没有被拒绝
2. Fulfilled(已兑现)：操作成功完成
3. Rejected(已拒绝)：操作失败

#### 示例代码

```javascript
// 创建Promise
function fetchData(url) {
    return new Promise((resolve, reject) => {
        // 模拟异步操作
        setTimeout(() => {
            if (url) {
                resolve(`Data from ${url}`);
            } else {
                reject(new Error('URL is required'));
            }
        }, 1000);
    });
}

// 使用Promise
fetchData('https://api.example.com/data')
    .then(data => {
        console.log(data);
        return fetchData('https://api.example.com/more-data');
    })
    .then(moreData => {
        console.log(moreData);
    })
    .catch(error => {
        console.error('Error:', error.message);
    });

// Promise.all - 并行执行多个Promise
Promise.all([
    fetchData('https://api.example.com/users'),
    fetchData('https://api.example.com/posts'),
    fetchData('https://api.example.com/comments')
])
.then(results => {
    const [users, posts, comments] = results;
    console.log('All data fetched:', { users, posts, comments });
})
.catch(error => {
    console.error('One or more requests failed:', error);
});

// 使用async/await（ES2017）
async function fetchAllData() {
    try {
        const users = await fetchData('https://api.example.com/users');
        const posts = await fetchData('https://api.example.com/posts');
        const comments = await fetchData('https://api.example.com/comments');
        
        return { users, posts, comments };
    } catch (error) {
        console.error('Error fetching data:', error.message);
        throw error;
    }
}
```

### 5. 什么是事件冒泡和事件捕获？如何阻止事件冒泡？

#### 答案解析

事件冒泡和事件捕获是DOM事件传播的两种机制：

1. **事件捕获**：事件从最外层元素开始向内传播到目标元素
2. **事件冒泡**：事件从目标元素开始向外传播到最外层元素

现代浏览器默认采用事件冒泡机制。

#### 示例代码

```html
<div id="outer">
    Outer Div
    <div id="inner">
        Inner Div
        <button id="btn">Click Me</button>
    </div>
</div>
```

```javascript
// 事件捕获阶段监听
document.getElementById('outer').addEventListener('click', function(e) {
    console.log('Outer div captured');
}, true); // 第三个参数设为true表示在捕获阶段触发

// 事件冒泡阶段监听
document.getElementById('outer').addEventListener('click', function(e) {
    console.log('Outer div bubbled');
}, false);

document.getElementById('inner').addEventListener('click', function(e) {
    console.log('Inner div clicked');
});

document.getElementById('btn').addEventListener('click', function(e) {
    console.log('Button clicked');
    
    // 阻止事件冒泡
    e.stopPropagation(); // 或者使用 e.cancelBubble = true (IE)
    
    // 阻止默认行为
    e.preventDefault();
});

// 输出顺序（如果没有阻止冒泡）：
// Outer div captured
// Button clicked
// Inner div clicked
// Outer div bubbled
```

### 6. Vue.js中的双向数据绑定是如何实现的？

#### 答案解析

Vue.js通过数据劫持结合发布-订阅模式来实现双向数据绑定。Vue 2.x使用Object.defineProperty()劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

#### 示例代码

```javascript
// 简化版Vue响应式原理实现
class Vue {
    constructor(options) {
        this.data = options.data;
        this.methods = options.methods;
        
        // 监听数据变化
        this.observe(this.data);
        
        // 编译模板
        this.compile(options.el);
    }
    
    observe(data) {
        Object.keys(data).forEach(key => {
            let value = data[key];
            const self = this;
            
            Object.defineProperty(data, key, {
                enumerable: true,
                configurable: true,
                get() {
                    console.log(`Getting ${key}: ${value}`);
                    return value;
                },
                set(newValue) {
                    console.log(`Setting ${key} to: ${newValue}`);
                    value = newValue;
                    // 触发视图更新（简化）
                    self.updateView();
                }
            });
        });
    }
    
    compile(el) {
        const element = document.querySelector(el);
        this.traverse(element);
    }
    
    traverse(node) {
        // 处理文本节点
        if (node.nodeType === 3) {
            const text = node.textContent;
            const reg = /\{\{(.*)\}\}/;
            
            if (reg.test(text)) {
                const key = RegExp.$1.trim();
                node.textContent = this.data[key];
                
                // 建立Watcher（简化）
                new Watcher(this, key, (newValue) => {
                    node.textContent = newValue;
                });
            }
        }
        // 处理元素节点
        else if (node.nodeType === 1) {
            // 处理v-model指令
            if (node.hasAttribute('v-model')) {
                const key = node.getAttribute('v-model');
                node.value = this.data[key];
                
                // 建立Watcher
                new Watcher(this, key, (newValue) => {
                    node.value = newValue;
                });
                
                // 监听输入事件
                node.addEventListener('input', (e) => {
                    this.data[key] = e.target.value;
                });
            }
        }
        
        // 递归处理子节点
        node.childNodes.forEach(child => this.traverse(child));
    }
    
    updateView() {
        // 简化的视图更新
        console.log('View updated');
    }
}

// 简单的Watcher类
class Watcher {
    constructor(vm, key, callback) {
        this.vm = vm;
        this.key = key;
        this.callback = callback;
        
        // 触发getter，建立依赖关系
        this.value = vm.data[key];
    }
    
    update() {
        const newValue = this.vm.data[this.key];
        if (newValue !== this.value) {
            this.callback(newValue);
            this.value = newValue;
        }
    }
}

// 使用示例
const app = new Vue({
    el: '#app',
    data: {
        message: 'Hello Vue!',
        count: 0
    },
    methods: {
        increment() {
            this.count++;
        }
    }
});
```

### 7. HTTP状态码的分类及其含义

#### 答案解析

HTTP状态码是服务器对客户端请求的响应状态的数字代码，分为5类：

#### 状态码分类

1. **1xx（信息性状态码）**：接收的请求正在处理
2. **2xx（成功状态码）**：请求正常处理完毕
3. **3xx（重定向状态码）**：需要后续操作才能完成这一请求
4. **4xx（客户端错误状态码）**：客户端原因导致服务器无法处理请求
5. **5xx（服务器错误状态码）**：服务器原因导致处理请求出错

#### 常见状态码

```javascript
// 常见HTTP状态码及含义
const httpStatusCodes = {
    // 2xx 成功
    200: 'OK - 请求成功',
    201: 'Created - 资源创建成功',
    204: 'No Content - 请求成功但无返回内容',
    
    // 3xx 重定向
    301: 'Moved Permanently - 永久重定向',
    302: 'Found - 临时重定向',
    304: 'Not Modified - 资源未修改，使用缓存',
    
    // 4xx 客户端错误
    400: 'Bad Request - 请求语法错误',
    401: 'Unauthorized - 未授权',
    403: 'Forbidden - 禁止访问',
    404: 'Not Found - 资源不存在',
    405: 'Method Not Allowed - 请求方法不允许',
    429: 'Too Many Requests - 请求过于频繁',
    
    // 5xx 服务器错误
    500: 'Internal Server Error - 服务器内部错误',
    502: 'Bad Gateway - 网关错误',
    503: 'Service Unavailable - 服务不可用',
    504: 'Gateway Timeout - 网关超时'
};

// 在实际项目中处理HTTP响应
async function handleApiResponse(url) {
    try {
        const response = await fetch(url);
        
        switch (response.status) {
            case 200:
                const data = await response.json();
                console.log('Success:', data);
                return data;
                
            case 404:
                throw new Error('Resource not found');
                
            case 500:
                throw new Error('Server error');
                
            default:
                throw new Error(`HTTP Error: ${response.status}`);
        }
    } catch (error) {
        console.error('API Error:', error.message);
        throw error;
    }
}
```

### 8. 如何优化前端性能？列举几种常用方法

#### 答案解析

前端性能优化可以从多个维度入手，包括资源加载、渲染性能、代码优化等。

#### 性能优化方法

```javascript
// 1. 图片优化
// 使用适当的图片格式
// WebP > JPEG > PNG for photos
// SVG for icons and simple graphics

// 响应式图片
/*
<picture>
  <source media="(max-width: 799px)" srcset="elva-480w-close-portrait.jpg">
  <source media="(min-width: 800px)" srcset="elva-800w.jpg">
  <img src="elva-800w.jpg" alt="Chris standing up holding his daughter Elva">
</picture>
*/

// 2. 代码分割和懒加载
// 使用动态import实现代码分割
async function loadModule() {
    const { heavyFunction } = await import('./heavy-module.js');
    return heavyFunction();
}

// 3. 防抖和节流
// 防抖 - 事件触发后等待一段时间再执行
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// 节流 - 限制函数执行频率
function throttle(func, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// 4. 虚拟滚动 - 处理大量列表数据
// 只渲染可视区域内的列表项
class VirtualList {
    constructor(container, items) {
        this.container = container;
        this.items = items;
        this.itemHeight = 50;
        this.visibleCount = Math.ceil(container.clientHeight / this.itemHeight);
        this.startIndex = 0;
        
        this.render();
        this.bindScroll();
    }
    
    render() {
        const fragment = document.createDocumentFragment();
        const endIndex = Math.min(this.startIndex + this.visibleCount, this.items.length);
        
        for (let i = this.startIndex; i < endIndex; i++) {
            const item = document.createElement('div');
            item.style.height = `${this.itemHeight}px`;
            item.textContent = this.items[i];
            fragment.appendChild(item);
        }
        
        this.container.innerHTML = '';
        this.container.appendChild(fragment);
    }
    
    bindScroll() {
        this.container.addEventListener('scroll', () => {
            this.startIndex = Math.floor(this.container.scrollTop / this.itemHeight);
            this.render();
        });
    }
}

// 5. Service Worker缓存
// 注册Service Worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
            .then(registration => {
                console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    });
}
```

### 9. 什么是跨域问题？如何解决？

#### 答案解析

跨域问题源于浏览器的同源策略，即协议、域名、端口任一不同就会被浏览器阻止。这是为了安全考虑，防止恶意网站窃取数据。

#### 同源策略示例

```
// 当前页面: http://example.com:8080
http://example.com:8080/page.html - 同源
https://example.com:8080/page.html - 不同源(协议不同)
http://www.example.com:8080/page.html - 不同源(域名不同)
http://example.com:8081/page.html - 不同源(端口不同)
```

#### 解决跨域问题的方法

```javascript
// 1. CORS (跨域资源共享) - 服务端设置
// 服务端响应头设置
/*
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
*/

// 2. JSONP (仅支持GET请求)
function jsonp(url, callback) {
    const script = document.createElement('script');
    const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
    
    window[callbackName] = function(data) {
        delete window[callbackName];
        document.body.removeChild(script);
        callback(data);
    };
    
    script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + callbackName;
    document.body.appendChild(script);
}

// 3. 代理服务器 - 开发环境常用
// webpack devServer配置
/*
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};
*/

// 4. Nginx反向代理 - 生产环境
/*
server {
    listen 80;
    server_name example.com;
    
    location /api/ {
        proxy_pass http://backend-server:3000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
*/

// 5. postMessage - iframe通信
// 父页面向iframe发送消息
const iframe = document.getElementById('myIframe');
iframe.contentWindow.postMessage('Hello from parent', 'https://child-domain.com');

// iframe接收消息
window.addEventListener('message', function(event) {
    if (event.origin !== 'https://parent-domain.com') return;
    console.log('Received message:', event.data);
});
```

### 10. React中的虚拟DOM和Diff算法原理

#### 答案解析

虚拟DOM是React的一个核心概念，它是真实DOM的轻量级JavaScript对象表示。React通过比较前后两次虚拟DOM的差异，计算出最小的DOM操作，然后批量更新真实DOM，从而提高性能。

#### Diff算法优化策略

1. **Tree Diff**：同一层级的节点进行比较
2. **Component Diff**：组件级别的比较
3. **Element Diff**：元素级别的比较，使用key优化

#### 示例代码

```javascript
// 简化的虚拟DOM实现
class VNode {
    constructor(tag, props, children) {
        this.tag = tag;
        this.props = props || {};
        this.children = children || [];
        this.key = props && props.key;
    }
}

// 创建虚拟DOM节点
function createElement(tag, props, ...children) {
    return new VNode(tag, props, children);
}

// 渲染虚拟DOM到真实DOM
function render(vnode, container) {
    const dom = createDOM(vnode);
    container.appendChild(dom);
}

function createDOM(vnode) {
    if (typeof vnode === 'string') {
        return document.createTextNode(vnode);
    }
    
    const dom = document.createElement(vnode.tag);
    
    // 设置属性
    Object.keys(vnode.props).forEach(key => {
        if (key !== 'key') {
            dom.setAttribute(key, vnode.props[key]);
        }
    });
    
    // 递归创建子节点
    vnode.children.forEach(child => {
        dom.appendChild(createDOM(child));
    });
    
    return dom;
}

// 简化的Diff算法
function diff(oldVNode, newVNode) {
    if (!oldVNode) {
        return { type: 'CREATE', newVNode };
    }
    
    if (!newVNode) {
        return { type: 'REMOVE', oldVNode };
    }
    
    if (oldVNode.tag !== newVNode.tag) {
        return { type: 'REPLACE', newVNode };
    }
    
    if (typeof oldVNode !== typeof newVNode) {
        return { type: 'TEXT', newVNode };
    }
    
    // 比较属性
    const patchProps = diffProps(oldVNode.props, newVNode.props);
    
    // 比较子节点
    const patchChildren = diffChildren(oldVNode.children, newVNode.children);
    
    return {
        type: 'UPDATE',
        props: patchProps,
        children: patchChildren
    };
}

function diffProps(oldProps, newProps) {
    const patches = [];
    
    // 找到新增和修改的属性
    Object.keys(newProps).forEach(key => {
        if (oldProps[key] !== newProps[key]) {
            patches.push({ type: 'SET_PROP', key, value: newProps[key] });
        }
    });
    
    // 找到删除的属性
    Object.keys(oldProps).forEach(key => {
        if (!(key in newProps)) {
            patches.push({ type: 'REMOVE_PROP', key });
        }
    });
    
    return patches;
}

// 使用示例
const oldVNode = createElement('div', { id: 'app' },
    createElement('h1', null, 'Hello'),
    createElement('p', null, 'World')
);

const newVNode = createElement('div', { id: 'app', className: 'container' },
    createElement('h1', null, 'Hello React'),
    createElement('p', null, 'Virtual DOM')
);

const patches = diff(oldVNode, newVNode);
console.log('Diff patches:', patches);
```

## 总结

这10个前端面试题涵盖了中级开发者需要掌握的核心知识点：

1. **JavaScript基础**：闭包、原型链、Promise
2. **CSS基础**：盒模型
3. **DOM操作**：事件机制
4. **现代框架**：Vue.js、React原理
5. **网络知识**：HTTP状态码、跨域问题
6. **性能优化**：各种优化技术

掌握这些问题不仅能帮助通过面试，更重要的是能够提升实际开发能力。