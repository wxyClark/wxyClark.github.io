# 代码层面的性能优化技巧？

## 概要回答

代码层面的性能优化是提升应用整体性能的关键环节，主要技巧包括：

1. **算法和数据结构优化**：选择合适的数据结构，优化算法复杂度
2. **循环优化**：减少循环内计算、避免嵌套循环、使用迭代器
3. **内存管理**：及时释放资源、避免内存泄漏、优化对象创建
4. **缓存策略**：合理使用缓存、避免缓存穿透和雪崩
5. **数据库优化**：优化查询语句、使用连接池、批量操作
6. **并发处理**：合理使用多线程、异步处理、避免竞态条件

## 深度解析

### 算法和数据结构优化

选择合适的数据结构和优化算法是性能优化的基础。

```php
<?php
/**
 * 算法和数据结构优化示例
 */
class AlgorithmOptimizer {
    
    /**
     * 数组查找优化示例
     */
    public static function arraySearchOptimization() {
        // 不好的做法：线性查找 O(n)
        $badExample = function($array, $target) {
            foreach ($array as $index => $value) {
                if ($value === $target) {
                    return $index;
                }
            }
            return false;
        };
        
        // 好的做法：使用哈希表查找 O(1)
        $goodExample = function($array, $target) {
            $hashMap = array_flip($array);
            return isset($hashMap[$target]) ? $hashMap[$target] : false;
        };
        
        // 测试数据
        $largeArray = range(1, 100000);
        $target = 99999;
        
        // 性能对比
        $start = microtime(true);
        $badExample($largeArray, $target);
        $badTime = microtime(true) - $start;
        
        $start = microtime(true);
        $goodExample($largeArray, $target);
        $goodTime = microtime(true) - $start;
        
        echo "线性查找时间: " . number_format($badTime * 1000, 4) . " ms\n";
        echo "哈希查找时间: " . number_format($goodTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($badTime / $goodTime, 2) . " 倍\n";
    }
    
    /**
     * 排序算法优化示例
     */
    public static function sortingOptimization() {
        // 不好的做法：冒泡排序 O(n²)
        $bubbleSort = function($array) {
            $n = count($array);
            for ($i = 0; $i < $n - 1; $i++) {
                for ($j = 0; $j < $n - $i - 1; $j++) {
                    if ($array[$j] > $array[$j + 1]) {
                        $temp = $array[$j];
                        $array[$j] = $array[$j + 1];
                        $array[$j + 1] = $temp;
                    }
                }
            }
            return $array;
        };
        
        // 好的做法：使用内置排序函数 O(n log n)
        $builtInSort = function($array) {
            sort($array);
            return $array;
        };
        
        // 测试数据
        $testArray = [];
        for ($i = 0; $i < 10000; $i++) {
            $testArray[] = rand(1, 100000);
        }
        
        // 性能对比
        $array1 = $testArray;
        $array2 = $testArray;
        
        $start = microtime(true);
        $bubbleSort($array1);
        $bubbleTime = microtime(true) - $start;
        
        $start = microtime(true);
        $builtInSort($array2);
        $builtinTime = microtime(true) - $start;
        
        echo "冒泡排序时间: " . number_format($bubbleTime * 1000, 2) . " ms\n";
        echo "内置排序时间: " . number_format($builtinTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($bubbleTime / $builtinTime, 2) . " 倍\n";
    }
    
    /**
     * 数据结构选择示例
     */
    public static function dataStructureSelection() {
        // 使用SplFixedArray优化数组操作
        $fixedArrayExample = function($size) {
            $array = new SplFixedArray($size);
            for ($i = 0; $i < $size; $i++) {
                $array[$i] = $i * 2;
            }
            return $array;
        };
        
        // 使用SplQueue优化队列操作
        $queueExample = function($operations) {
            $queue = new SplQueue();
            for ($i = 0; $i < $operations; $i++) {
                $queue->enqueue($i);
                if ($queue->count() > 1000) {
                    $queue->dequeue();
                }
            }
            return $queue;
        };
        
        // 使用SplStack优化栈操作
        $stackExample = function($operations) {
            $stack = new SplStack();
            for ($i = 0; $i < $operations; $i++) {
                $stack->push($i);
                if ($stack->count() > 1000) {
                    $stack->pop();
                }
            }
            return $stack;
        };
        
        echo "数据结构优化示例完成\n";
    }
}

// 运行示例
// AlgorithmOptimizer::arraySearchOptimization();
// AlgorithmOptimizer::sortingOptimization();
// AlgorithmOptimizer::dataStructureSelection();
?>
```

### 循环优化

循环是程序中常见的性能瓶颈，需要特别注意优化。

```php
<?php
/**
 * 循环优化示例
 */
class LoopOptimizer {
    
    /**
     * 循环内计算优化
     */
    public static function loopCalculationOptimization() {
        $data = range(1, 100000);
        $multiplier = 2.5;
        
        // 不好的做法：循环内重复计算
        $badExample = function($data, $multiplier) {
            $result = [];
            for ($i = 0; $i < count($data); $i++) {
                // 每次都调用count()和重复计算
                $result[] = $data[$i] * sqrt(pow($multiplier, 2));
            }
            return $result;
        };
        
        // 好的做法：提前计算不变量
        $goodExample = function($data, $multiplier) {
            $result = [];
            $dataCount = count($data); // 提前计算
            $calculatedValue = sqrt(pow($multiplier, 2)); // 提前计算
            
            for ($i = 0; $i < $dataCount; $i++) {
                $result[] = $data[$i] * $calculatedValue;
            }
            return $result;
        };
        
        // 性能对比
        $start = microtime(true);
        $badExample($data, $multiplier);
        $badTime = microtime(true) - $start;
        
        $start = microtime(true);
        $goodExample($data, $multiplier);
        $goodTime = microtime(true) - $start;
        
        echo "不良循环时间: " . number_format($badTime * 1000, 4) . " ms\n";
        echo "优化循环时间: " . number_format($goodTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($badTime / $goodTime, 2) . " 倍\n";
    }
    
    /**
     * 嵌套循环优化
     */
    public static function nestedLoopOptimization() {
        $size = 1000;
        $array1 = range(1, $size);
        $array2 = range(1, $size);
        
        // 不好的做法：O(n²)复杂度
        $badExample = function($array1, $array2) {
            $result = [];
            foreach ($array1 as $item1) {
                foreach ($array2 as $item2) {
                    if ($item1 === $item2) {
                        $result[] = $item1;
                    }
                }
            }
            return $result;
        };
        
        // 好的做法：使用哈希表优化到O(n)
        $goodExample = function($array1, $array2) {
            $hashSet = array_flip($array2);
            $result = [];
            foreach ($array1 as $item1) {
                if (isset($hashSet[$item1])) {
                    $result[] = $item1;
                }
            }
            return $result;
        };
        
        // 性能对比
        $start = microtime(true);
        $badExample($array1, $array2);
        $badTime = microtime(true) - $start;
        
        $start = microtime(true);
        $goodExample($array1, $array2);
        $goodTime = microtime(true) - $start;
        
        echo "嵌套循环时间: " . number_format($badTime * 1000, 2) . " ms\n";
        echo "优化后时间: " . number_format($goodTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($badTime / $goodTime, 2) . " 倍\n";
    }
    
    /**
     * 循环内对象创建优化
     */
    public static function objectCreationInLoopOptimization() {
        // 不好的做法：循环内创建对象
        $badExample = function($iterations) {
            $results = [];
            for ($i = 0; $i < $iterations; $i++) {
                $processor = new DataProcessor(); // 每次都创建新对象
                $results[] = $processor->process($i);
            }
            return $results;
        };
        
        // 好的做法：循环外创建对象
        $goodExample = function($iterations) {
            $results = [];
            $processor = new DataProcessor(); // 只创建一次
            for ($i = 0; $i < $iterations; $i++) {
                $results[] = $processor->process($i);
            }
            return $results;
        };
        
        // 性能对比
        $iterations = 10000;
        
        $start = microtime(true);
        $badExample($iterations);
        $badTime = microtime(true) - $start;
        
        $start = microtime(true);
        $goodExample($iterations);
        $goodTime = microtime(true) - $start;
        
        echo "循环内创建对象时间: " . number_format($badTime * 1000, 4) . " ms\n";
        echo "循环外创建对象时间: " . number_format($goodTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($badTime / $goodTime, 2) . " 倍\n";
    }
}

class DataProcessor {
    public function process($data) {
        return $data * 2;
    }
}

// 运行示例
// LoopOptimizer::loopCalculationOptimization();
// LoopOptimizer::nestedLoopOptimization();
// LoopOptimizer::objectCreationInLoopOptimization();
?>
```

### 内存管理优化

合理的内存管理可以显著提升应用性能并避免内存泄漏。

```php
<?php
/**
 * 内存管理优化示例
 */
class MemoryManager {
    
    /**
     * 内存使用监控
     */
    public static function monitorMemoryUsage() {
        $startMemory = memory_get_usage();
        echo "初始内存使用: " . self::formatBytes($startMemory) . "\n";
        
        // 创建大量数据
        $largeArray = [];
        for ($i = 0; $i < 100000; $i++) {
            $largeArray[] = str_repeat('a', 100);
        }
        
        $peakMemory = memory_get_peak_usage();
        echo "峰值内存使用: " . self::formatBytes($peakMemory) . "\n";
        
        // 及时释放内存
        unset($largeArray);
        gc_collect_cycles(); // 强制垃圾回收
        
        $endMemory = memory_get_usage();
        echo "释放后内存使用: " . self::formatBytes($endMemory) . "\n";
        echo "内存释放量: " . self::formatBytes($peakMemory - $endMemory) . "\n";
    }
    
    /**
     * 格式化字节数
     */
    private static function formatBytes($bytes, $precision = 2) {
        $units = ['B', 'KB', 'MB', 'GB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);
        return round($bytes, $precision) . ' ' . $units[$pow];
    }
    
    /**
     * 对象池模式实现
     */
    public static function objectPoolingExample() {
        class ObjectPool {
            private $pool = [];
            private $created = 0;
            
            public function acquire() {
                if (count($this->pool) > 0) {
                    return array_pop($this->pool);
                }
                
                $this->created++;
                return new ExpensiveObject();
            }
            
            public function release($object) {
                if (count($this->pool) < 10) { // 限制池大小
                    $this->pool[] = $object;
                }
                // 超出池大小的对象会被自动销毁
            }
            
            public function getCreatedCount() {
                return $this->created;
            }
        }
        
        class ExpensiveObject {
            private $data;
            
            public function __construct() {
                // 模拟昂贵的对象创建过程
                $this->data = str_repeat('x', 1000);
            }
            
            public function processData($input) {
                return strtoupper($input);
            }
            
            public function reset() {
                // 重置对象状态
                $this->data = str_repeat('x', 1000);
            }
        }
        
        // 使用对象池
        $pool = new ObjectPool();
        
        // 不使用对象池的情况
        $start = microtime(true);
        $createdWithoutPool = 0;
        for ($i = 0; $i < 1000; $i++) {
            $obj = new ExpensiveObject();
            $obj->processData("test$i");
            $createdWithoutPool++;
        }
        $timeWithoutPool = microtime(true) - $start;
        
        // 使用对象池的情况
        $start = microtime(true);
        for ($i = 0; $i < 1000; $i++) {
            $obj = $pool->acquire();
            $obj->processData("test$i");
            $pool->release($obj);
        }
        $timeWithPool = microtime(true) - $start;
        
        echo "不使用对象池时间: " . number_format($timeWithoutPool * 1000, 4) . " ms\n";
        echo "使用对象池时间: " . number_format($timeWithPool * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($timeWithoutPool / $timeWithPool, 2) . " 倍\n";
        echo "对象池创建数量: " . $pool->getCreatedCount() . "\n";
    }
    
    /**
     * 引用传递优化
     */
    public static function referencePassingOptimization() {
        // 大数组示例
        $largeArray = [];
        for ($i = 0; $i < 50000; $i++) {
            $largeArray[] = ['id' => $i, 'name' => "User$i"];
        }
        
        // 不好的做法：值传递（会复制整个数组）
        $badExample = function($array) {
            foreach ($array as $item) {
                // 处理每个项目
            }
            return $array;
        };
        
        // 好的做法：引用传递（避免复制）
        $goodExample = function(&$array) {
            foreach ($array as &$item) {
                // 处理每个项目
            }
            unset($item); // 断开引用
            return $array;
        };
        
        // 性能对比
        $array1 = $largeArray;
        $array2 = $largeArray;
        
        $start = microtime(true);
        $badExample($array1);
        $badTime = microtime(true) - $start;
        
        $start = microtime(true);
        $goodExample($array2);
        $goodTime = microtime(true) - $start;
        
        echo "值传递时间: " . number_format($badTime * 1000, 4) . " ms\n";
        echo "引用传递时间: " . number_format($goodTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($badTime / $goodTime, 2) . " 倍\n";
    }
    
    /**
     * 内存泄漏检测
     */
    public static function memoryLeakDetection() {
        class LeakDetector {
            private static $objects = [];
            private static $counter = 0;
            
            public static function track($object) {
                self::$counter++;
                self::$objects[spl_object_hash($object)] = [
                    'object' => $object,
                    'created' => microtime(true),
                    'counter' => self::$counter
                ];
            }
            
            public static function getLeaks() {
                $leaks = [];
                foreach (self::$objects as $hash => $info) {
                    if (!is_object($info['object'])) {
                        $leaks[] = $info;
                    }
                }
                return $leaks;
            }
            
            public static function cleanup() {
                foreach (self::$objects as $hash => $info) {
                    if (!is_object($info['object'])) {
                        unset(self::$objects[$hash]);
                    }
                }
            }
        }
        
        // 模拟内存泄漏
        for ($i = 0; $i < 100; $i++) {
            $obj = new stdClass();
            $obj->data = str_repeat('x', 1000);
            LeakDetector::track($obj);
            // 不释放$obj，造成内存泄漏
        }
        
        // 检测泄漏
        $leaks = LeakDetector::getLeaks();
        echo "检测到内存泄漏对象数量: " . count($leaks) . "\n";
        
        // 清理
        LeakDetector::cleanup();
    }
}

// 运行示例
// MemoryManager::monitorMemoryUsage();
// MemoryManager::objectPoolingExample();
// MemoryManager::referencePassingOptimization();
// MemoryManager::memoryLeakDetection();
?>
```

### 缓存策略优化

合理的缓存策略可以显著减少重复计算和数据库查询。

```php
<?php
/**
 * 缓存策略优化示例
 */
class CacheOptimizer {
    
    private static $memoryCache = [];
    
    /**
     * 简单内存缓存实现
     */
    public static function simpleCache($key, $callback, $ttl = 300) {
        // 检查缓存是否存在且未过期
        if (isset(self::$memoryCache[$key])) {
            $cached = self::$memoryCache[$key];
            if (time() - $cached['timestamp'] < $ttl) {
                return $cached['data'];
            }
        }
        
        // 缓存未命中，执行回调函数
        $data = $callback();
        
        // 存储到缓存
        self::$memoryCache[$key] = [
            'data' => $data,
            'timestamp' => time()
        ];
        
        return $data;
    }
    
    /**
     * LRU缓存实现
     */
    public static function lruCacheExample() {
        class LRUCache {
            private $capacity;
            private $cache;
            private $order;
            
            public function __construct($capacity) {
                $this->capacity = $capacity;
                $this->cache = [];
                $this->order = [];
            }
            
            public function get($key) {
                if (!isset($this->cache[$key])) {
                    return null;
                }
                
                // 更新访问顺序
                $this->updateOrder($key);
                return $this->cache[$key];
            }
            
            public function put($key, $value) {
                if (isset($this->cache[$key])) {
                    // 更新现有键值
                    $this->cache[$key] = $value;
                    $this->updateOrder($key);
                } else {
                    // 添加新键值
                    if (count($this->cache) >= $this->capacity) {
                        // 移除最久未使用的项
                        $lruKey = array_shift($this->order);
                        unset($this->cache[$lruKey]);
                    }
                    
                    $this->cache[$key] = $value;
                    $this->order[] = $key;
                }
            }
            
            private function updateOrder($key) {
                // 移除旧位置
                $index = array_search($key, $this->order);
                if ($index !== false) {
                    array_splice($this->order, $index, 1);
                }
                // 添加到末尾（最新）
                $this->order[] = $key;
            }
            
            public function getStats() {
                return [
                    'size' => count($this->cache),
                    'capacity' => $this->capacity,
                    'hit_rate' => $this->hitRate ?? 0
                ];
            }
        }
        
        // 使用LRU缓存
        $cache = new LRUCache(3);
        
        $cache->put('a', 1);
        $cache->put('b', 2);
        $cache->put('c', 3);
        
        echo "获取 a: " . $cache->get('a') . "\n"; // 应该返回 1
        $cache->put('d', 4); // 移除 'b'
        
        echo "获取 b: " . $cache->get('b') . "\n"; // 应该返回 null
        echo "获取 c: " . $cache->get('c') . "\n"; // 应该返回 3
        echo "获取 d: " . $cache->get('d') . "\n"; // 应该返回 4
    }
    
    /**
     * 缓存穿透防护
     */
    public static function cachePenetrationProtection() {
        class CacheWithNullProtection {
            private static $cache = [];
            
            public static function get($key, $fetchCallback) {
                // 检查缓存
                if (isset(self::$cache[$key])) {
                    $value = self::$cache[$key];
                    // 如果是空值标记，返回null而不调用回调
                    if ($value === 'NULL_MARKER') {
                        return null;
                    }
                    return $value;
                }
                
                // 缓存未命中，调用回调获取数据
                $value = $fetchCallback($key);
                
                // 如果数据为空，存储空值标记
                if ($value === null) {
                    self::$cache[$key] = 'NULL_MARKER';
                } else {
                    self::$cache[$key] = $value;
                }
                
                return $value;
            }
            
            public static function invalidate($key) {
                unset(self::$cache[$key]);
            }
        }
        
        // 模拟数据库查询
        $database = [
            'user:1' => ['id' => 1, 'name' => 'Alice'],
            'user:2' => ['id' => 2, 'name' => 'Bob']
            // user:3 不存在
        ];
        
        $fetchUser = function($key) use ($database) {
            echo "查询数据库: $key\n";
            return $database[$key] ?? null;
        };
        
        // 第一次查询存在的用户
        $user1 = CacheWithNullProtection::get('user:1', $fetchUser);
        echo "用户1: " . json_encode($user1) . "\n";
        
        // 第二次查询相同的用户（应该从缓存获取）
        $user1Again = CacheWithNullProtection::get('user:1', $fetchUser);
        echo "用户1 (缓存): " . json_encode($user1Again) . "\n";
        
        // 查询不存在的用户
        $user3 = CacheWithNullProtection::get('user:3', $fetchUser);
        echo "用户3: " . json_encode($user3) . "\n";
        
        // 再次查询不存在的用户（应该从缓存获取空值标记）
        $user3Again = CacheWithNullProtection::get('user:3', $fetchUser);
        echo "用户3 (缓存): " . json_encode($user3Again) . "\n";
    }
    
    /**
     * 缓存雪崩防护
     */
    public static function cacheAvalancheProtection() {
        class CacheWithExpirationJitter {
            private static $cache = [];
            
            public static function get($key, $fetchCallback, $baseTtl = 300) {
                // 检查缓存
                if (isset(self::$cache[$key])) {
                    $cached = self::$cache[$key];
                    if (time() < $cached['expire']) {
                        return $cached['data'];
                    }
                }
                
                // 缓存未命中或已过期，获取新数据
                $data = $fetchCallback($key);
                
                // 添加随机抖动到过期时间（±60秒）
                $jitter = rand(-60, 60);
                $expire = time() + $baseTtl + $jitter;
                
                // 存储到缓存
                self::$cache[$key] = [
                    'data' => $data,
                    'expire' => $expire
                ];
                
                return $data;
            }
        }
        
        // 模拟批量数据更新
        $fetchData = function($key) {
            echo "获取数据: $key\n";
            return "data_for_$key";
        };
        
        // 模拟多个并发请求
        $keys = ['data:1', 'data:2', 'data:3', 'data:4', 'data:5'];
        
        foreach ($keys as $key) {
            $data = CacheWithExpirationJitter::get($key, $fetchData);
            echo "获取到: $data\n";
        }
    }
}

// 运行示例
// CacheOptimizer::simpleCache('expensive_calculation', function() {
//     // 模拟昂贵的计算
//     sleep(1);
//     return 'result';
// });
// 
// CacheOptimizer::lruCacheExample();
// CacheOptimizer::cachePenetrationProtection();
// CacheOptimizer::cacheAvalancheProtection();
?>
```

### 数据库优化

数据库操作往往是性能瓶颈，需要特别优化。

```php
<?php
/**
 * 数据库优化示例
 */
class DatabaseOptimizer {
    
    private $pdo;
    
    public function __construct($dsn, $username, $password) {
        $this->pdo = new PDO($dsn, $username, $password);
        $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    }
    
    /**
     * 连接池模拟
     */
    public static function connectionPoolingExample() {
        class SimpleConnectionPool {
            private $pool = [];
            private $config;
            private $maxConnections = 5;
            
            public function __construct($config) {
                $this->config = $config;
            }
            
            public function getConnection() {
                // 如果池中有可用连接，直接返回
                if (!empty($this->pool)) {
                    return array_pop($this->pool);
                }
                
                // 创建新连接
                $pdo = new PDO(
                    $this->config['dsn'],
                    $this->config['username'],
                    $this->config['password']
                );
                $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
                
                return $pdo;
            }
            
            public function releaseConnection($pdo) {
                // 如果池未满，将连接放回池中
                if (count($this->pool) < $this->maxConnections) {
                    $this->pool[] = $pdo;
                } else {
                    // 池已满，关闭连接
                    $pdo = null;
                }
            }
        }
        
        // 使用连接池
        $config = [
            'dsn' => 'sqlite::memory:',
            'username' => '',
            'password' => ''
        ];
        
        $pool = new SimpleConnectionPool($config);
        
        // 模拟多个数据库操作
        for ($i = 0; $i < 10; $i++) {
            $conn = $pool->getConnection();
            // 执行数据库操作
            $pool->releaseConnection($conn);
        }
        
        echo "连接池示例完成\n";
    }
    
    /**
     * 批量操作优化
     */
    public function batchOperationOptimization() {
        // 创建测试表
        $this->pdo->exec("
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                email TEXT
            )
        ");
        
        // 不好的做法：逐条插入
        $badInsert = function($pdo, $users) {
            $stmt = $pdo->prepare("INSERT INTO users (name, email) VALUES (?, ?)");
            foreach ($users as $user) {
                $stmt->execute([$user['name'], $user['email']]);
            }
        };
        
        // 好的做法：批量插入
        $goodInsert = function($pdo, $users) {
            $pdo->beginTransaction();
            try {
                $stmt = $pdo->prepare("INSERT INTO users (name, email) VALUES (?, ?)");
                foreach ($users as $user) {
                    $stmt->execute([$user['name'], $user['email']]);
                }
                $pdo->commit();
            } catch (Exception $e) {
                $pdo->rollback();
                throw $e;
            }
        };
        
        // 准备测试数据
        $users = [];
        for ($i = 0; $i < 1000; $i++) {
            $users[] = [
                'name' => "User $i",
                'email' => "user$i@example.com"
            ];
        }
        
        // 性能对比
        $start = microtime(true);
        $badInsert($this->pdo, $users);
        $badTime = microtime(true) - $start;
        
        // 清理数据
        $this->pdo->exec("DELETE FROM users");
        
        $start = microtime(true);
        $goodInsert($this->pdo, $users);
        $goodTime = microtime(true) - $start;
        
        echo "逐条插入时间: " . number_format($badTime * 1000, 2) . " ms\n";
        echo "批量插入时间: " . number_format($goodTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($badTime / $goodTime, 2) . " 倍\n";
    }
    
    /**
     * 查询优化示例
     */
    public function queryOptimization() {
        // 创建测试表和索引
        $this->pdo->exec("
            CREATE TABLE IF NOT EXISTS products (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                category TEXT,
                price REAL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ");
        
        // 创建索引
        $this->pdo->exec("CREATE INDEX IF NOT EXISTS idx_category_price ON products(category, price)");
        
        // 插入测试数据
        $stmt = $this->pdo->prepare("INSERT INTO products (name, category, price) VALUES (?, ?, ?)");
        for ($i = 0; $i < 10000; $i++) {
            $stmt->execute([
                "Product $i",
                ['Electronics', 'Books', 'Clothing'][rand(0, 2)],
                rand(10, 1000)
            ]);
        }
        
        // 不好的查询：全表扫描
        $badQuery = function($pdo) {
            $stmt = $pdo->prepare("
                SELECT * FROM products 
                WHERE category = ? AND price > ?
                ORDER BY created_at DESC
            ");
            $stmt->execute(['Electronics', 500]);
            return $stmt->fetchAll();
        };
        
        // 好的查询：使用索引
        $goodQuery = function($pdo) {
            $stmt = $pdo->prepare("
                SELECT id, name, price FROM products 
                WHERE category = ? AND price > ?
                ORDER BY price DESC
                LIMIT 50
            ");
            $stmt->execute(['Electronics', 500]);
            return $stmt->fetchAll();
        };
        
        // 性能对比
        $start = microtime(true);
        $badQuery($this->pdo);
        $badTime = microtime(true) - $start;
        
        $start = microtime(true);
        $goodQuery($this->pdo);
        $goodTime = microtime(true) - $start;
        
        echo "不良查询时间: " . number_format($badTime * 1000, 4) . " ms\n";
        echo "优化查询时间: " . number_format($goodTime * 1000, 4) . " ms\n";
        echo "性能提升: " . number_format($badTime / $goodTime, 2) . " 倍\n";
    }
}

// 运行示例
// DatabaseOptimizer::connectionPoolingExample();
// $db = new DatabaseOptimizer('sqlite::memory:', '', '');
// $db->batchOperationOptimization();
// $db->queryOptimization();
?>
```

### 并发处理优化

合理的并发处理可以充分利用系统资源，提升性能。

```php
<?php
/**
 * 并发处理优化示例
 */
class ConcurrencyOptimizer {
    
    /**
     * 异步处理示例
     */
    public static function asyncProcessingExample() {
        // 模拟异步任务
        class AsyncTask {
            private $callback;
            private $args;
            
            public function __construct($callback, $args = []) {
                $this->callback = $callback;
                $this->args = $args;
            }
            
            public function execute() {
                return call_user_func_array($this->callback, $this->args);
            }
        }
        
        // 任务队列
        class TaskQueue {
            private $tasks = [];
            private $results = [];
            
            public function addTask($task) {
                $this->tasks[] = $task;
            }
            
            public function executeAll() {
                foreach ($this->tasks as $index => $task) {
                    $this->results[$index] = $task->execute();
                }
                return $this->results;
            }
            
            public function executeConcurrent() {
                // 模拟并发执行（实际应用中可能使用多进程或多线程）
                $this->results = [];
                foreach ($this->tasks as $index => $task) {
                    // 在实际应用中，这里可能会使用pcntl_fork或类似机制
                    $this->results[$index] = $task->execute();
                }
                return $this->results;
            }
        }
        
        // 模拟耗时任务
        $slowTask = function($name, $delay) {
            sleep($delay);
            return "Task $name completed after $delay seconds";
        };
        
        // 顺序执行
        $start = microtime(true);
        $result1 = $slowTask('A', 1);
        $result2 = $slowTask('B', 1);
        $result3 = $slowTask('C', 1);
        $sequentialTime = microtime(true) - $start;
        
        // 并发执行（模拟）
        $start = microtime(true);
        $queue = new TaskQueue();
        $queue->addTask(new AsyncTask($slowTask, ['A', 1]));
        $queue->addTask(new AsyncTask($slowTask, ['B', 1]));
        $queue->addTask(new AsyncTask($slowTask, ['C', 1]));
        $concurrentResults = $queue->executeAll(); // 实际应用中使用executeConcurrent()
        $concurrentTime = microtime(true) - $start;
        
        echo "顺序执行时间: " . number_format($sequentialTime, 2) . " 秒\n";
        echo "并发执行时间: " . number_format($concurrentTime, 2) . " 秒\n";
        echo "时间节省: " . number_format($sequentialTime - $concurrentTime, 2) . " 秒\n";
    }
    
    /**
     * 多进程处理示例
     */
    public static function multiprocessingExample() {
        if (!function_exists('pcntl_fork')) {
            echo "PCNTL扩展不可用，跳过多进程示例\n";
            return;
        }
        
        class ProcessPool {
            private $maxProcesses;
            private $runningProcesses = [];
            
            public function __construct($maxProcesses = 4) {
                $this->maxProcesses = $maxProcesses;
            }
            
            public function submit($callback, $args = []) {
                // 等待有空闲进程
                while (count($this->runningProcesses) >= $this->maxProcesses) {
                    $this->wait();
                }
                
                // 创建子进程
                $pid = pcntl_fork();
                if ($pid == -1) {
                    throw new Exception("无法创建子进程");
                } elseif ($pid == 0) {
                    // 子进程
                    $result = call_user_func_array($callback, $args);
                    exit(0);
                } else {
                    // 父进程
                    $this->runningProcesses[$pid] = true;
                }
            }
            
            private function wait() {
                $pid = pcntl_wait($status);
                unset($this->runningProcesses[$pid]);
            }
            
            public function waitForAll() {
                while (!empty($this->runningProcesses)) {
                    $this->wait();
                }
            }
        }
        
        // 模拟任务
        $task = function($id, $duration) {
            echo "任务 $id 开始 (PID: " . getmypid() . ")\n";
            sleep($duration);
            echo "任务 $id 完成\n";
        };
        
        // 使用进程池执行任务
        $pool = new ProcessPool(3);
        
        $start = microtime(true);
        for ($i = 1; $i <= 6; $i++) {
            $pool->submit($task, [$i, 2]);
        }
        $pool->waitForAll();
        $multiprocessTime = microtime(true) - $start;
        
        echo "多进程执行完成，总时间: " . number_format($multiprocessTime, 2) . " 秒\n";
    }
    
    /**
     * 读写锁示例
     */
    public static function readWriteLockExample() {
        class ReadWriteLock {
            private $readers = 0;
            private $writer = false;
            private $mutex;
            
            public function __construct() {
                $this->mutex = fopen('/tmp/rwlock.mutex', 'w+');
            }
            
            public function readLock() {
                flock($this->mutex, LOCK_EX);
                $this->readers++;
                if ($this->readers == 1) {
                    // 第一个读者需要获得写锁
                    // 在实际实现中，这里需要更复杂的同步机制
                }
                flock($this->mutex, LOCK_UN);
            }
            
            public function readUnlock() {
                flock($this->mutex, LOCK_EX);
                $this->readers--;
                if ($this->readers == 0) {
                    // 最后一个读者释放写锁
                }
                flock($this->mutex, LOCK_UN);
            }
            
            public function writeLock() {
                // 获得写锁
                // 在实际实现中，这里需要阻塞直到没有读者和写者
            }
            
            public function writeUnlock() {
                // 释放写锁
            }
        }
        
        echo "读写锁示例框架完成\n";
    }
}

// 运行示例
// ConcurrencyOptimizer::asyncProcessingExample();
// ConcurrencyOptimizer::multiprocessingExample();
// ConcurrencyOptimizer::readWriteLockExample();
?>
```

### 代码层面性能优化最佳实践

1. **算法和数据结构**：
   - 选择合适的数据结构以匹配使用场景
   - 优化算法复杂度，避免不必要的嵌套循环
   - 使用PHP内置函数而非自己实现

2. **循环优化**：
   - 将循环不变量移出循环体
   - 避免在循环内创建大对象
   - 使用foreach替代for（当不需要索引时）

3. **内存管理**：
   - 及时释放大对象和数组
   - 使用引用传递避免大数组复制
   - 实现对象池模式复用昂贵对象

4. **缓存策略**：
   - 合理使用缓存避免重复计算
   - 实施缓存穿透和雪崩防护
   - 使用LRU等策略管理缓存淘汰

5. **数据库优化**：
   - 使用连接池减少连接开销
   - 实施批量操作减少查询次数
   - 创建合适的索引优化查询性能

6. **并发处理**：
   - 合理使用异步处理提升吞吐量
   - 使用多进程/多线程充分利用CPU
   - 实施同步机制避免竞态条件

### 总结

代码层面的性能优化是一个系统性的工程，需要从算法、数据结构、内存管理、缓存策略、数据库操作和并发处理等多个维度进行考虑。通过合理的优化措施，可以显著提升应用的性能和用户体验。关键是要建立性能监控意识，定期分析和优化代码性能，同时在开发过程中就注重性能设计。