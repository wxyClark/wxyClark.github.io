# 图片懒加载和响应式图片的实现？

## 概要回答

图片懒加载和响应式图片是提升Web性能和用户体验的重要技术，实现方法包括：

1. **图片懒加载**：
   - 使用Intersection Observer API监听图片进入视口
   - 传统滚动事件监听实现兼容性方案
   - 占位符和加载状态管理

2. **响应式图片**：
   - 使用`<picture>`元素和`<source>`标签
   - `srcset`和`sizes`属性实现不同分辨率适配
   - 根据设备像素比(dPR)加载合适尺寸图片

3. **现代实现**：
   - 利用浏览器原生懒加载属性loading="lazy"
   - 结合CDN和图片优化服务
   - WebP等现代图片格式支持

## 深度解析

### 图片懒加载实现

图片懒加载是一种延迟加载技术，只有当图片即将进入用户视口时才开始加载，从而减少初始页面加载时间。

```php
<?php
/**
 * 图片懒加载工具类
 */
class ImageLazyLoader {
    
    /**
     * 生成懒加载图片HTML
     */
    public static function lazyImage($src, $alt = '', $classes = '', $attributes = []) {
        // 设置默认属性
        $defaultAttrs = [
            'data-src' => $src,
            'alt' => $alt,
            'class' => "lazy-image $classes",
            'loading' => 'lazy' // 现代浏览器原生支持
        ];
        
        // 合并自定义属性
        $attrs = array_merge($defaultAttrs, $attributes);
        
        // 生成属性字符串
        $attrString = '';
        foreach ($attrs as $key => $value) {
            $attrString .= " $key=\"" . htmlspecialchars($value) . "\"";
        }
        
        // 返回img标签（初始src为空或占位图）
        return "<img src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 200'%3E%3C/svg%3E\"$attrString>";
    }
    
    /**
     * 生成带占位符的懒加载图片
     */
    public static function lazyImageWithPlaceholder($src, $alt = '', $placeholder = null, $classes = '', $attributes = []) {
        $placeholderSrc = $placeholder ?: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 200'%3E%3Crect width='300' height='200' fill='%23f0f0f0'/%3E%3C/svg%3E";
        
        $defaultAttrs = [
            'data-src' => $src,
            'alt' => $alt,
            'class' => "lazy-image placeholder $classes",
            'src' => $placeholderSrc,
            'loading' => 'lazy'
        ];
        
        $attrs = array_merge($defaultAttrs, $attributes);
        
        $attrString = '';
        foreach ($attrs as $key => $value) {
            $attrString .= " $key=\"" . htmlspecialchars($value) . "\"";
        }
        
        return "<img$attrString>";
    }
    
    /**
     * 生成懒加载背景图片容器
     */
    public static function lazyBackground($src, $classes = '', $attributes = []) {
        $defaultAttrs = [
            'class' => "lazy-bg $classes",
            'data-bg' => $src
        ];
        
        $attrs = array_merge($defaultAttrs, $attributes);
        
        $attrString = '';
        foreach ($attrs as $key => $value) {
            $attrString .= " $key=\"" . htmlspecialchars($value) . "\"";
        }
        
        return "<div$attrString></div>";
    }
    
    /**
     * 获取Intersection Observer懒加载JavaScript
     */
    public static function getIntersectionObserverScript() {
        return '
<script>
(function() {
    "use strict";
    
    // 检查浏览器支持
    if (!("IntersectionObserver" in window)) {
        // 降级到传统懒加载
        loadAllImages();
        return;
    }
    
    // 创建观察器
    const imageObserver = new IntersectionObserver(function(entries, observer) {
        entries.forEach(function(entry) {
            if (entry.isIntersecting) {
                loadImage(entry.target);
                observer.unobserve(entry.target);
            }
        });
    }, {
        rootMargin: "50px 0px", // 提前50px开始加载
        threshold: 0.01
    });
    
    // 观察所有懒加载图片
    document.querySelectorAll(".lazy-image").forEach(function(img) {
        imageObserver.observe(img);
    });
    
    // 观察懒加载背景图片
    document.querySelectorAll(".lazy-bg").forEach(function(el) {
        imageObserver.observe(el);
    });
    
    // 加载单张图片
    function loadImage(img) {
        const src = img.dataset.src;
        if (!src) return;
        
        // 添加加载状态类
        img.classList.add("loading");
        
        // 创建新的图片对象来预加载
        const image = new Image();
        image.onload = function() {
            // 设置真实图片源
            if (img.tagName.toLowerCase() === "img") {
                img.src = src;
            } else {
                img.style.backgroundImage = "url(" + src + ")";
            }
            
            // 移除加载状态类，添加加载完成类
            img.classList.remove("loading");
            img.classList.add("loaded");
        };
        
        image.onerror = function() {
            // 加载失败处理
            img.classList.remove("loading");
            img.classList.add("error");
            console.warn("图片加载失败:", src);
        };
        
        image.src = src;
    }
    
    // 加载所有图片（降级方案）
    function loadAllImages() {
        document.querySelectorAll(".lazy-image[data-src]").forEach(loadImage);
        document.querySelectorAll(".lazy-bg[data-bg]").forEach(loadImage);
    }
    
    // 暴露全局方法
    window.loadAllLazyImages = loadAllImages;
})();
</script>';
    }
    
    /**
     * 获取传统滚动事件懒加载JavaScript
     */
    public static function getScrollEventScript() {
        return '
<script>
(function() {
    "use strict";
    
    let lazyImages = [].slice.call(document.querySelectorAll(".lazy-image, .lazy-bg"));
    let active = false;
    
    const lazyLoad = function() {
        if (active === false) {
            active = true;
            
            setTimeout(function() {
                lazyImages.forEach(function(lazyImage) {
                    if ((lazyImage.getBoundingClientRect().top <= (window.innerHeight + 50) && 
                         lazyImage.getBoundingClientRect().bottom >= -50) && 
                         getComputedStyle(lazyImage).display !== "none") {
                        
                        // 加载图片
                        if (lazyImage.dataset.src) {
                            lazyImage.src = lazyImage.dataset.src;
                            lazyImage.removeAttribute("data-src");
                        }
                        
                        if (lazyImage.dataset.bg) {
                            lazyImage.style.backgroundImage = "url(" + lazyImage.dataset.bg + ")";
                            lazyImage.removeAttribute("data-bg");
                        }
                        
                        lazyImage.classList.remove("lazy-image", "lazy-bg");
                        lazyImage.classList.add("loaded");
                        
                        // 从待加载列表中移除
                        lazyImages = lazyImages.filter(function(image) {
                            return image !== lazyImage;
                        });
                        
                        if (lazyImages.length === 0) {
                            // 所有图片加载完成，移除事件监听
                            document.removeEventListener("scroll", lazyLoad);
                            window.removeEventListener("resize", lazyLoad);
                            window.removeEventListener("orientationchange", lazyLoad);
                        }
                    }
                });
                
                active = false;
            }, 200);
        }
    };
    
    // 初始化
    lazyLoad();
    
    // 绑定事件
    document.addEventListener("scroll", lazyLoad);
    window.addEventListener("resize", lazyLoad);
    window.addEventListener("orientationchange", lazyLoad);
})();
</script>';
    }
    
    /**
     * 生成CSS样式
     */
    public static function getLazyLoadCSS() {
        return '
<style>
.lazy-image, .lazy-bg {
    transition: opacity 0.3s ease-in-out;
    opacity: 1;
}

.lazy-image.placeholder {
    background-color: #f0f0f0;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
}

.lazy-image.loading {
    opacity: 0.5;
}

.lazy-image.loaded {
    opacity: 1;
}

.lazy-image.error {
    opacity: 0.3;
    background-color: #ffdddd;
}

.lazy-bg {
    background-color: #f0f0f0;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
}

.lazy-bg.loading {
    opacity: 0.7;
}

.lazy-bg.loaded {
    opacity: 1;
}
</style>';
    }
}

// 使用示例
// echo ImageLazyLoader::getLazyLoadCSS();
// echo ImageLazyLoader::lazyImage('/images/large-photo.jpg', '描述文字', 'photo');
// echo ImageLazyLoader::lazyImageWithPlaceholder('/images/banner.jpg', '横幅图片', null, 'banner');
// echo ImageLazyLoader::lazyBackground('/images/background.jpg', 'hero-section');
// echo ImageLazyLoader::getIntersectionObserverScript();
?>
```

### 响应式图片实现

响应式图片技术可以根据设备屏幕尺寸、像素密度等因素加载最合适尺寸的图片。

```php
<?php
/**
 * 响应式图片工具类
 */
class ResponsiveImage {
    
    /**
     * 生成响应式图片HTML
     */
    public static function responsiveImage($src, $alt = '', $breakpoints = [], $sizes = null, $classes = '') {
        // 默认断点配置
        $defaultBreakpoints = [
            ['width' => 320, 'density' => 1],
            ['width' => 320, 'density' => 2],
            ['width' => 480, 'density' => 1],
            ['width' => 480, 'density' => 2],
            ['width' => 768, 'density' => 1],
            ['width' => 768, 'density' => 2],
            ['width' => 1024, 'density' => 1],
            ['width' => 1024, 'density' => 2],
            ['width' => 1200, 'density' => 1],
            ['width' => 1200, 'density' => 2]
        ];
        
        $breakpoints = $breakpoints ?: $defaultBreakpoints;
        
        // 生成srcset属性
        $srcset = self::generateSrcset($src, $breakpoints);
        
        // 默认sizes属性
        $defaultSizes = $sizes ?: '(max-width: 320px) 280px, (max-width: 480px) 440px, (max-width: 768px) 720px, (max-width: 1024px) 960px, 1200px';
        
        return "<img src=\"$src\" srcset=\"$srcset\" sizes=\"$defaultSizes\" alt=\"$alt\" class=\"$classes\" loading=\"lazy\">";
    }
    
    /**
     * 生成srcset字符串
     */
    private static function generateSrcset($baseSrc, $breakpoints) {
        $srcsetParts = [];
        $pathInfo = pathinfo($baseSrc);
        $baseName = $pathInfo['filename'];
        $extension = $pathInfo['extension'];
        $dir = $pathInfo['dirname'];
        
        foreach ($breakpoints as $bp) {
            $width = $bp['width'];
            $density = $bp['density'];
            
            // 生成不同尺寸的图片URL
            $resizedSrc = "$dir/{$baseName}-{$width}w.{$extension}";
            if ($density == 1) {
                $srcsetParts[] = "$resizedSrc {$width}w";
            } else {
                $srcsetParts[] = "$resizedSrc {$density}x";
            }
        }
        
        return implode(', ', $srcsetParts);
    }
    
    /**
     * 生成<picture>元素
     */
    public static function pictureElement($sources, $fallbackSrc, $alt = '', $classes = '') {
        $html = "<picture class=\"$classes\">\n";
        
        // 添加<source>标签
        foreach ($sources as $source) {
            $attrs = '';
            if (isset($source['media'])) {
                $attrs .= " media=\"{$source['media']}\"";
            }
            if (isset($source['srcset'])) {
                $attrs .= " srcset=\"{$source['srcset']}\"";
            }
            if (isset($source['type'])) {
                $attrs .= " type=\"{$source['type']}\"";
            }
            $html .= "    <source$attrs>\n";
        }
        
        // 添加<img>标签作为降级
        $html .= "    <img src=\"$fallbackSrc\" alt=\"$alt\" loading=\"lazy\">\n";
        $html .= "</picture>";
        
        return $html;
    }
    
    /**
     * 生成Art Direction响应式图片
     */
    public static function artDirectionImage($config) {
        $sources = [];
        
        // 为不同断点生成不同的图片
        if (isset($config['sources'])) {
            foreach ($config['sources'] as $source) {
                $sources[] = [
                    'media' => $source['media'],
                    'srcset' => $source['srcset'],
                    'type' => $source['type'] ?? ''
                ];
            }
        }
        
        return self::pictureElement($sources, $config['fallback'], $config['alt'], $config['classes'] ?? '');
    }
    
    /**
     * 生成现代格式图片（WebP等）
     */
    public static function modernFormatImage($jpgSrc, $webpSrc, $alt = '', $classes = '') {
        $sources = [
            [
                'type' => 'image/webp',
                'srcset' => $webpSrc
            ]
        ];
        
        return self::pictureElement($sources, $jpgSrc, $alt, $classes);
    }
    
    /**
     * 批量生成响应式图片配置
     */
    public static function generateResponsiveConfig($baseSrc, $options = []) {
        $options = array_merge([
            'widths' => [320, 480, 768, 1024, 1200, 1920],
            'densities' => [1, 2],
            'formats' => ['jpg', 'webp'],
            'quality' => [80, 85]
        ], $options);
        
        $config = [
            'base' => $baseSrc,
            'variants' => []
        ];
        
        foreach ($options['widths'] as $width) {
            foreach ($options['densities'] as $density) {
                foreach ($options['formats'] as $format) {
                    $quality = in_array($format, ['webp', 'avif']) ? 
                              $options['quality'][1] : $options['quality'][0];
                    
                    $config['variants'][] = [
                        'width' => $width,
                        'density' => $density,
                        'format' => $format,
                        'quality' => $quality,
                        'filename' => self::generateFilename($baseSrc, $width, $density, $format)
                    ];
                }
            }
        }
        
        return $config;
    }
    
    private static function generateFilename($baseSrc, $width, $density, $format) {
        $pathInfo = pathinfo($baseSrc);
        $baseName = $pathInfo['filename'];
        $suffix = $density > 1 ? "@{$density}x" : '';
        return "{$pathInfo['dirname']}/{$baseName}-{$width}w{$suffix}.{$format}";
    }
    
    /**
     * 获取响应式图片CSS
     */
    public static function getResponsiveCSS() {
        return '
<style>
/* 响应式图片容器 */
.responsive-img-container {
    position: relative;
    width: 100%;
    height: 0;
    padding-bottom: 56.25%; /* 16:9 宽高比 */
    overflow: hidden;
}

.responsive-img-container img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 不同设备的优化 */
@media (max-width: 480px) {
    .responsive-img {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
    }
}

@media (min-resolution: 2dppx) {
    .responsive-img {
        image-rendering: auto;
    }
}
</style>';
    }
}

// 使用示例
// echo ResponsiveImage::getResponsiveCSS();

// 基本响应式图片
// echo ResponsiveImage::responsiveImage('/images/photo.jpg', '描述文字');

// Picture元素
// $sources = [
//     [
//         'media' => '(max-width: 768px)',
//         'srcset' => '/images/photo-mobile.webp',
//         'type' => 'image/webp'
//     ],
//     [
//         'media' => '(min-width: 769px)',
//         'srcset' => '/images/photo-desktop.webp',
//         'type' => 'image/webp'
//     ]
// ];
// echo ResponsiveImage::pictureElement($sources, '/images/photo.jpg', '描述文字');

// 现代格式支持
// echo ResponsiveImage::modernFormatImage('/images/photo.jpg', '/images/photo.webp', '描述文字');
?>
```

### 高级懒加载实现

更高级的懒加载实现可以包含错误处理、优先级管理等功能。

```php
<?php
/**
 * 高级图片懒加载类
 */
class AdvancedLazyLoader {
    
    private $config;
    
    public function __construct($config = []) {
        $this->config = array_merge([
            'rootMargin' => '50px',
            'threshold' => 0.01,
            'preloadOffset' => 100,
            'retryAttempts' => 3,
            'retryDelay' => 1000
        ], $config);
    }
    
    /**
     * 生成高级懒加载图片
     */
    public static function advancedLazyImage($src, $alt = '', $priority = 'normal', $classes = '', $attributes = []) {
        $defaultAttrs = [
            'data-src' => $src,
            'data-priority' => $priority,
            'alt' => $alt,
            'class' => "advanced-lazy-image priority-$priority $classes",
            'loading' => 'lazy',
            'decoding' => 'async'
        ];
        
        $attrs = array_merge($defaultAttrs, $attributes);
        
        $attrString = '';
        foreach ($attrs as $key => $value) {
            $attrString .= " $key=\"" . htmlspecialchars($value) . "\"";
        }
        
        return "<img src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 200'%3E%3C/svg%3E\"$attrString>";
    }
    
    /**
     * 获取高级懒加载JavaScript
     */
    public static function getAdvancedScript($config = []) {
        $configJson = json_encode($config);
        
        return "
<script>
(function() {
    'use strict';
    
    const config = $configJson || {
        rootMargin: '50px',
        threshold: 0.01,
        preloadOffset: 100,
        retryAttempts: 3,
        retryDelay: 1000
    };
    
    class AdvancedLazyLoader {
        constructor(config) {
            this.config = config;
            this.observer = null;
            this.loadingQueue = new Map();
            this.retryCount = new Map();
            this.init();
        }
        
        init() {
            if (!('IntersectionObserver' in window)) {
                this.fallbackLoad();
                return;
            }
            
            this.createObserver();
            this.observeImages();
            this.setupPriorityLoading();
        }
        
        createObserver() {
            this.observer = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        this.loadImage(entry.target);
                        this.observer.unobserve(entry.target);
                    }
                });
            }, {
                rootMargin: this.config.rootMargin,
                threshold: this.config.threshold
            });
        }
        
        observeImages() {
            document.querySelectorAll('.advanced-lazy-image').forEach((img) => {
                this.observer.observe(img);
            });
        }
        
        loadImage(img) {
            const src = img.dataset.src;
            if (!src) return;
            
            const priority = img.dataset.priority || 'normal';
            
            // 添加到加载队列
            this.loadingQueue.set(img, {src, priority});
            
            // 根据优先级决定加载策略
            if (priority === 'high') {
                this.loadImmediately(img, src);
            } else {
                this.loadWithDelay(img, src);
            }
        }
        
        loadImmediately(img, src) {
            this.doLoad(img, src);
        }
        
        loadWithDelay(img, src) {
            // 延迟加载低优先级图片
            setTimeout(() => {
                this.doLoad(img, src);
            }, 100);
        }
        
        doLoad(img, src) {
            img.classList.add('loading');
            
            const image = new Image();
            
            image.onload = () => {
                img.src = src;
                img.classList.remove('loading');
                img.classList.add('loaded');
                this.loadingQueue.delete(img);
                
                // 触发自定义事件
                img.dispatchEvent(new CustomEvent('lazyloaded', {
                    detail: { src: src }
                }));
            };
            
            image.onerror = () => {
                this.handleLoadError(img, src);
            };
            
            image.src = src;
        }
        
        handleLoadError(img, src) {
            const attempts = this.retryCount.get(img) || 0;
            
            if (attempts < this.config.retryAttempts) {
                // 重试加载
                this.retryCount.set(img, attempts + 1);
                
                setTimeout(() => {
                    this.doLoad(img, src);
                }, this.config.retryDelay * Math.pow(2, attempts));
            } else {
                // 最终失败处理
                img.classList.remove('loading');
                img.classList.add('error');
                this.loadingQueue.delete(img);
                
                console.warn('图片加载失败:', src);
                
                // 触发错误事件
                img.dispatchEvent(new CustomEvent('lazyerror', {
                    detail: { src: src, attempts: attempts }
                }));
            }
        }
        
        fallbackLoad() {
            // 降级到传统加载方式
            document.querySelectorAll('.advanced-lazy-image[data-src]').forEach((img) => {
                img.src = img.dataset.src;
                img.classList.add('loaded');
            });
        }
        
        setupPriorityLoading() {
            // 监听页面可见性变化
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    // 页面变为可见时，优先加载高优先级图片
                    this.loadHighPriorityImages();
                }
            });
        }
        
        loadHighPriorityImages() {
            document.querySelectorAll('.advanced-lazy-image.priority-high[data-src]').forEach((img) => {
                if (this.loadingQueue.has(img)) {
                    const {src} = this.loadingQueue.get(img);
                    this.loadImmediately(img, src);
                }
            });
        }
        
        // 公共方法：手动加载所有图片
        loadAll() {
            document.querySelectorAll('.advanced-lazy-image[data-src]').forEach((img) => {
                if (this.loadingQueue.has(img)) {
                    const {src} = this.loadingQueue.get(img);
                    this.loadImmediately(img, src);
                }
            });
        }
        
        // 公共方法：预加载指定图片
        preload(src, callback) {
            const image = new Image();
            image.onload = () => {
                if (callback) callback(null, image);
            };
            image.onerror = () => {
                if (callback) callback(new Error('预加载失败'), null);
            };
            image.src = src;
        }
    }
    
    // 初始化懒加载器
    window.advancedLazyLoader = new AdvancedLazyLoader(config);
    
    // 页面加载完成后初始化
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            window.advancedLazyLoader = new AdvancedLazyLoader(config);
        });
    } else {
        window.advancedLazyLoader = new AdvancedLazyLoader(config);
    }
})();
</script>";
    }
    
    /**
     * 获取高级懒加载CSS
     */
    public static function getAdvancedCSS() {
        return '
<style>
.advanced-lazy-image {
    transition: opacity 0.3s ease, filter 0.3s ease;
    opacity: 1;
    background-color: #f5f5f5;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
}

.advanced-lazy-image.loading {
    opacity: 0.7;
    filter: blur(2px);
}

.advanced-lazy-image.loaded {
    opacity: 1;
    filter: blur(0);
    background-image: none;
}

.advanced-lazy-image.error {
    opacity: 0.5;
    background-color: #ffebee;
    background-image: url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\'%3E%3Cpath fill=\'%23ccc\' d=\'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\'/%3E%3C/svg%3E");
    background-size: 40px;
    background-repeat: no-repeat;
    background-position: center;
}

/* 优先级样式 */
.advanced-lazy-image.priority-high {
    background-color: #e3f2fd;
}

.advanced-lazy-image.priority-low {
    background-color: #fafafa;
}

/* 渐进式加载效果 */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.advanced-lazy-image.loaded {
    animation: fadeIn 0.3s ease-in-out;
}
</style>';
    }
    
    /**
     * 生成带有进度指示的懒加载图片
     */
    public static function progressLazyImage($src, $alt = '', $classes = '', $attributes = []) {
        $defaultAttrs = [
            'data-src' => $src,
            'alt' => $alt,
            'class' => "progress-lazy-image $classes",
            'loading' => 'lazy'
        ];
        
        $attrs = array_merge($defaultAttrs, $attributes);
        
        $attrString = '';
        foreach ($attrs as $key => $value) {
            $attrString .= " $key=\"" . htmlspecialchars($value) . "\"";
        }
        
        $html = "<div class=\"lazy-image-wrapper\">\n";
        $html .= "    <img src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 200'%3E%3C/svg%3E\"$attrString>\n";
        $html .= "    <div class=\"lazy-progress\">\n";
        $html .= "        <div class=\"lazy-progress-bar\"></div>\n";
        $html .= "    </div>\n";
        $html .= "</div>";
        
        return $html;
    }
    
    /**
     * 获取进度指示CSS
     */
    public static function getProgressCSS() {
        return '
<style>
.lazy-image-wrapper {
    position: relative;
    display: inline-block;
    overflow: hidden;
}

.progress-lazy-image {
    display: block;
    transition: opacity 0.3s ease;
}

.lazy-progress {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 80%;
    height: 4px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 2px;
    transform: translate(-50%, -50%);
    overflow: hidden;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.lazy-image-wrapper.loading .lazy-progress {
    opacity: 1;
}

.lazy-progress-bar {
    height: 100%;
    background-color: #1976d2;
    width: 0%;
    transition: width 0.2s ease;
    border-radius: 2px;
}

.lazy-image-wrapper.loading .lazy-progress-bar {
    animation: progressIndeterminate 1.5s infinite linear;
}

@keyframes progressIndeterminate {
    0% { width: 0%; }
    50% { width: 70%; }
    100% { width: 100%; }
}

.lazy-image-wrapper.loaded .lazy-progress {
    opacity: 0;
}
</style>';
    }
}

// 使用示例
// echo AdvancedLazyLoader::getAdvancedCSS();
// echo AdvancedLazyLoader::advancedLazyImage('/images/hero.jpg', '英雄图片', 'high', 'hero-image');
// echo AdvancedLazyLoader::progressLazyImage('/images/gallery-1.jpg', '画廊图片');
// echo AdvancedLazyLoader::getProgressCSS();
// echo AdvancedLazyLoader::getAdvancedScript();
?>
```

### 与CDN和图片优化服务集成

现代网站通常会结合CDN和专业的图片优化服务来进一步提升性能。

```php
<?php
/**
 * CDN图片优化集成类
 */
class CDNImageOptimizer {
    
    private $cdnBaseUrl;
    private $imageService;
    
    public function __construct($cdnBaseUrl, $imageService = 'cloudinary') {
        $this->cdnBaseUrl = rtrim($cdnBaseUrl, '/');
        $this->imageService = $imageService;
    }
    
    /**
     * 生成Cloudinary优化图片URL
     */
    public function cloudinaryImage($publicId, $options = []) {
        $defaults = [
            'width' => 'auto',
            'height' => 'auto',
            'crop' => 'fill',
            'gravity' => 'auto',
            'quality' => 'auto',
            'format' => 'auto'
        ];
        
        $options = array_merge($defaults, $options);
        
        // 构建变换参数
        $transformParams = [];
        foreach ($options as $key => $value) {
            if ($value !== null) {
                $transformParams[] = $key . '_' . $value;
            }
        }
        
        $transformation = implode(',', $transformParams);
        return $this->cdnBaseUrl . '/' . $transformation . '/' . $publicId;
    }
    
    /**
     * 生成Imgix优化图片URL
     */
    public function imgixImage($path, $options = []) {
        $defaults = [
            'auto' => 'format,compress',
            'fit' => 'crop',
            'q' => 80
        ];
        
        $options = array_merge($defaults, $options);
        
        // 构建查询参数
        $queryParams = [];
        foreach ($options as $key => $value) {
            $queryParams[] = $key . '=' . urlencode($value);
        }
        
        $queryString = implode('&', $queryParams);
        return $this->cdnBaseUrl . '/' . ltrim($path, '/') . '?' . $queryString;
    }
    
    /**
     * 生成响应式图片集
     */
    public function responsiveImageSet($basePath, $widths = [320, 480, 768, 1024, 1200], $options = []) {
        $srcset = [];
        
        foreach ($widths as $width) {
            $opt = array_merge($options, ['width' => $width]);
            $url = $this->getImageUrl($basePath, $opt);
            $srcset[] = $url . ' ' . $width . 'w';
        }
        
        return implode(', ', $srcset);
    }
    
    /**
     * 根据服务类型生成图片URL
     */
    private function getImageUrl($path, $options) {
        switch ($this->imageService) {
            case 'cloudinary':
                return $this->cloudinaryImage($path, $options);
            case 'imgix':
                return $this->imgixImage($path, $options);
            default:
                return $this->cdnBaseUrl . '/' . ltrim($path, '/');
        }
    }
    
    /**
     * 生成LazyBlur技术的图片
     */
    public function lazyBlurImage($path, $blurPath, $alt = '', $classes = '') {
        $lowQualitySrc = $this->getImageUrl($blurPath, ['width' => 50, 'quality' => 20, 'blur' => 100]);
        $highQualitySrc = $this->getImageUrl($path, ['quality' => 80]);
        
        return "
<div class=\"lazy-blur-container $classes\">
    <img class=\"lazy-blur-preview\" src=\"$lowQualitySrc\" alt=\"$alt\">
    <img class=\"lazy-blur-full\" data-src=\"$highQualitySrc\" alt=\"$alt\" loading=\"lazy\">
</div>";
    }
    
    /**
     * 获取LazyBlur CSS
     */
    public static function getLazyBlurCSS() {
        return '
<style>
.lazy-blur-container {
    position: relative;
    overflow: hidden;
    background-color: #f5f5f5;
}

.lazy-blur-preview {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    filter: blur(20px);
    transform: scale(1.1);
    transition: opacity 0.3s ease;
}

.lazy-blur-full {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.lazy-blur-full.loaded {
    opacity: 1;
}

.lazy-blur-full.loaded + .lazy-blur-preview {
    opacity: 0;
}
</style>';
    }
    
    /**
     * 获取LazyBlur JavaScript
     */
    public static function getLazyBlurScript() {
        return '
<script>
document.addEventListener("DOMContentLoaded", function() {
    const lazyImages = document.querySelectorAll(".lazy-blur-full");
    
    if ("IntersectionObserver" in window) {
        const imageObserver = new IntersectionObserver(function(entries, observer) {
            entries.forEach(function(entry) {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    const src = img.dataset.src;
                    
                    if (src) {
                        const fullImage = new Image();
                        fullImage.onload = function() {
                            img.src = src;
                            img.classList.add("loaded");
                        };
                        fullImage.src = src;
                    }
                    
                    observer.unobserve(img);
                }
            });
        });
        
        lazyImages.forEach(function(img) {
            imageObserver.observe(img);
        });
    } else {
        // 降级处理
        lazyImages.forEach(function(img) {
            const src = img.dataset.src;
            if (src) {
                img.src = src;
                img.classList.add("loaded");
            }
        });
    }
});
</script>';
    }
}

// 使用示例
// $cdn = new CDNImageOptimizer('https://res.cloudinary.com/demo/image/upload');
// echo $cdn->cloudinaryImage('sample.jpg', ['width' => 800, 'height' => 600]);

// 响应式图片集
// $srcset = $cdn->responsiveImageSet('sample.jpg', [320, 480, 768, 1024]);
// echo "<img srcset=\"$srcset\" sizes=\"(max-width: 768px) 100vw, 50vw\" src=\"sample.jpg\">";

// LazyBlur图片
// echo CDNImageOptimizer::getLazyBlurCSS();
// echo $cdn->lazyBlurImage('sample.jpg', 'sample_blur.jpg', '描述文字');
// echo CDNImageOptimizer::getLazyBlurScript();
?>
```

### 图片懒加载和响应式图片最佳实践

1. **懒加载实现**：
   - 优先使用Intersection Observer API
   - 提供传统滚动事件监听作为降级方案
   - 合理设置rootMargin提前加载
   - 实现错误处理和重试机制

2. **响应式图片**：
   - 使用srcset和sizes属性适配不同屏幕
   - 利用`<picture>`元素实现Art Direction
   - 支持WebP等现代图片格式
   - 根据设备像素比提供合适分辨率

3. **性能优化**：
   - 结合CDN和图片优化服务
   - 实现渐进式加载效果
   - 使用适当的占位符技术
   - 控制并发加载数量

4. **用户体验**：
   - 提供加载状态反馈
   - 优雅处理加载失败情况
   - 考虑用户网络状况
   - 支持用户偏好设置（如数据节省模式）

### 总结

图片懒加载和响应式图片技术是现代Web开发中提升性能和用户体验的重要手段。通过合理实现这些技术，可以显著减少初始页面加载时间，优化不同设备上的显示效果，并提供更好的用户交互体验。关键是要根据具体需求选择合适的实现方案，并持续监控和优化性能表现。