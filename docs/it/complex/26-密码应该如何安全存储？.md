# 密码应该如何安全存储？

## 概要回答

密码安全存储是Web应用安全的基础，主要方法包括：

1. **使用强哈希算法**：使用bcrypt、scrypt或Argon2等专为密码设计的哈希算法
2. **加盐处理**：为每个密码生成唯一的随机盐值
3. **适当的迭代次数**：设置足够的计算复杂度以抵御暴力破解
4. **定期更新**：随着硬件性能提升定期调整安全参数
5. **安全传输**：使用HTTPS传输密码，避免明文传输

## 深度解析

### 密码存储安全原则

密码安全存储的核心原则是即使数据库被泄露，攻击者也无法轻易获得用户的明文密码。这需要使用单向哈希函数和适当的防护措施。

```php
<?php
/**
 * 密码存储安全原则演示
 */
class PasswordSecurityPrinciples {
    
    /**
     * 不安全的密码存储方式
     */
    public static function insecurePasswordStorage() {
        return [
            'plaintext' => [
                'description' => '明文存储',
                'example' => "INSERT INTO users (username, password) VALUES ('user', '123456')",
                'risk' => '数据库泄露直接暴露所有密码'
            ],
            'simple_hash' => [
                'description' => '简单哈希（MD5/SHA1）',
                'example' => "INSERT INTO users (username, password) VALUES ('user', MD5('123456'))",
                'risk' => '容易受到彩虹表和暴力破解攻击'
            ],
            'shared_salt' => [
                'description' => '共享盐值',
                'example' => "INSERT INTO users (username, password) VALUES ('user', SHA256('123456' + 'shared_salt'))",
                'risk' => '相同密码产生相同哈希，容易批量破解'
            ]
        ];
    }
    
    /**
     * 安全的密码存储方式
     */
    public static function securePasswordStorage() {
        return [
            'bcrypt' => [
                'description' => 'bcrypt算法',
                'features' => [
                    '内置盐值生成',
                    '可调节计算复杂度',
                    '抵御彩虹表攻击',
                    '广泛采用和测试'
                ]
            ],
            'argon2' => [
                'description' => 'Argon2算法（推荐）',
                'features' => [
                    '内存硬函数',
                    '抵御ASIC和GPU破解',
                    '可配置内存和时间成本',
                    'Password Hashing Competition获胜者'
                ]
            ],
            'scrypt' => [
                'description' => 'scrypt算法',
                'features' => [
                    '高内存需求',
                    '抵御硬件加速破解',
                    '可调节参数'
                ]
            ]
        ];
    }
    
    /**
     * 密码安全存储要素
     */
    public static function storageElements() {
        return [
            'hash_algorithm' => '强哈希算法',
            'salt' => '唯一盐值',
            'cost_factor' => '计算复杂度',
            'pepper' => '胡椒（可选的全局密钥）',
            'key_stretching' => '密钥拉伸'
        ];
    }
}

// 密码存储演进历程
// 1. 明文存储 -> 2. 简单哈希 -> 3. 加盐哈希 -> 4. 自适应哈希 -> 5. 内存硬函数
?>
```

### bcrypt实现

bcrypt是目前广泛使用的密码哈希算法，具有内置盐值生成和可调节复杂度的特点。

```php
<?php
/**
 * bcrypt密码哈希实现
 */
class BcryptPasswordHasher {
    private $cost;
    
    public function __construct($cost = 12) {
        if ($cost < 4 || $cost > 31) {
            throw new InvalidArgumentException('Cost must be between 4 and 31');
        }
        $this->cost = $cost;
    }
    
    /**
     * 哈希密码
     */
    public function hash($password) {
        if (strlen($password) > 72) {
            throw new InvalidArgumentException('Password must not exceed 72 characters');
        }
        
        $hash = password_hash($password, PASSWORD_BCRYPT, [
            'cost' => $this->cost
        ]);
        
        if ($hash === false) {
            throw new RuntimeException('Password hashing failed');
        }
        
        return $hash;
    }
    
    /**
     * 验证密码
     */
    public function verify($password, $hash) {
        return password_verify($password, $hash);
    }
    
    /**
     * 检查是否需要重新哈希
     */
    public function needsRehash($hash) {
        return password_needs_rehash($hash, PASSWORD_BCRYPT, [
            'cost' => $this->cost
        ]);
    }
    
    /**
     * 生成安全的随机密码
     */
    public static function generateSecurePassword($length = 16) {
        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
        $password = '';
        
        for ($i = 0; $i < $length; $i++) {
            $password .= $chars[random_int(0, strlen($chars) - 1)];
        }
        
        return $password;
    }
    
    /**
     * 评估密码强度
     */
    public static function evaluatePasswordStrength($password) {
        $score = 0;
        $feedback = [];
        
        // 长度检查
        if (strlen($password) >= 8) {
            $score += 25;
        } else {
            $feedback[] = '密码长度至少8位';
        }
        
        // 大写字母
        if (preg_match('/[A-Z]/', $password)) {
            $score += 25;
        } else {
            $feedback[] = '包含大写字母';
        }
        
        // 小写字母
        if (preg_match('/[a-z]/', $password)) {
            $score += 25;
        } else {
            $feedback[] = '包含小写字母';
        }
        
        // 数字
        if (preg_match('/[0-9]/', $password)) {
            $score += 15;
        } else {
            $feedback[] = '包含数字';
        }
        
        // 特殊字符
        if (preg_match('/[^A-Za-z0-9]/', $password)) {
            $score += 10;
        } else {
            $feedback[] = '包含特殊字符';
        }
        
        // 评估等级
        if ($score >= 90) {
            $strength = '很强';
        } elseif ($score >= 70) {
            $strength = '强';
        } elseif ($score >= 50) {
            $strength = '中等';
        } else {
            $strength = '弱';
        }
        
        return [
            'score' => $score,
            'strength' => $strength,
            'feedback' => $feedback
        ];
    }
}

// 使用示例
// $hasher = new BcryptPasswordHasher(12);
// 
// // 哈希密码
// $password = 'user_password_123';
// $hash = $hasher->hash($password);
// echo "Hashed password: $hash\n";
// 
// // 验证密码
// if ($hasher->verify($password, $hash)) {
//     echo "Password verified successfully\n";
// }
// 
// // 检查是否需要重新哈希
// if ($hasher->needsRehash($hash)) {
//     echo "Password needs rehashing\n";
// }
?>
```

### Argon2实现

Argon2是Password Hashing Competition的获胜者，被认为是目前最安全的密码哈希算法。

```php
<?php
/**
 * Argon2密码哈希实现
 */
class Argon2PasswordHasher {
    private $memoryCost;
    private $timeCost;
    private $threads;
    
    public function __construct($memoryCost = 65536, $timeCost = 4, $threads = 3) {
        $this->memoryCost = $memoryCost;
        $this->timeCost = $timeCost;
        $this->threads = $threads;
    }
    
    /**
     * 哈希密码（Argon2id）
     */
    public function hash($password) {
        if (!defined('PASSWORD_ARGON2ID')) {
            throw new RuntimeException('Argon2id not supported in this PHP version');
        }
        
        $hash = password_hash($password, PASSWORD_ARGON2ID, [
            'memory_cost' => $this->memoryCost,
            'time_cost' => $this->timeCost,
            'threads' => $this->threads
        ]);
        
        if ($hash === false) {
            throw new RuntimeException('Password hashing failed');
        }
        
        return $hash;
    }
    
    /**
     * 验证密码
     */
    public function verify($password, $hash) {
        return password_verify($password, $hash);
    }
    
    /**
     * 检查是否需要重新哈希
     */
    public function needsRehash($hash) {
        if (!defined('PASSWORD_ARGON2ID')) {
            return false;
        }
        
        return password_needs_rehash($hash, PASSWORD_ARGON2ID, [
            'memory_cost' => $this->memoryCost,
            'time_cost' => $this->timeCost,
            'threads' => $this->threads
        ]);
    }
    
    /**
     * 获取哈希信息
     */
    public static function getInfo($hash) {
        return password_get_info($hash);
    }
    
    /**
     * 性能测试
     */
    public function benchmark($iterations = 10) {
        $password = 'benchmark_password_' . time();
        $times = [];
        
        for ($i = 0; $i < $iterations; $i++) {
            $start = microtime(true);
            $hash = $this->hash($password);
            $end = microtime(true);
            
            $times[] = $end - $start;
        }
        
        $avgTime = array_sum($times) / count($times);
        
        return [
            'average_time' => $avgTime,
            'min_time' => min($times),
            'max_time' => max($times),
            'iterations' => $iterations
        ];
    }
    
    /**
     * 参数优化建议
     */
    public static function getOptimalParameters($targetTime = 0.5) {
        // 根据目标时间调整参数
        // 这是一个简化的实现，实际应用中需要更复杂的测试
        return [
            'memory_cost' => 65536,  // 64 MB
            'time_cost' => 4,        // 4次迭代
            'threads' => 3           // 3个线程
        ];
    }
}

// 使用示例
// if (defined('PASSWORD_ARGON2ID')) {
//     $hasher = new Argon2PasswordHasher();
//     
//     // 哈希密码
//     $password = 'secure_password_123';
//     $hash = $hasher->hash($password);
//     echo "Argon2 hash: $hash\n";
//     
//     // 验证密码
//     if ($hasher->verify($password, $hash)) {
//         echo "Password verified with Argon2\n";
//     }
//     
//     // 获取哈希信息
//     $info = Argon2PasswordHasher::getInfo($hash);
//     print_r($info);
// }
?>
```

### 密码存储系统实现

```php
<?php
/**
 * 完整的密码存储系统
 */
class SecurePasswordStorage {
    private $hasher;
    private $pepper;
    private $migrationHasher;
    
    public function __construct($algorithm = 'argon2', $pepper = null) {
        $this->pepper = $pepper ?? getenv('PASSWORD_PEPPER') ?? '';
        
        switch ($algorithm) {
            case 'argon2':
                if (defined('PASSWORD_ARGON2ID')) {
                    $this->hasher = new Argon2PasswordHasher();
                } else {
                    $this->hasher = new BcryptPasswordHasher();
                }
                break;
            case 'bcrypt':
            default:
                $this->hasher = new BcryptPasswordHasher();
                break;
        }
        
        // 迁移哈希器（用于旧密码升级）
        $this->migrationHasher = new BcryptPasswordHasher(10);
    }
    
    /**
     * 安全地存储密码
     */
    public function storePassword($userId, $password) {
        // 预处理密码
        $processedPassword = $this->applyPepper($password);
        
        // 哈希密码
        $hash = $this->hasher->hash($processedPassword);
        
        // 存储到数据库（示例）
        $this->saveToDatabase($userId, $hash);
        
        return $hash;
    }
    
    /**
     * 验证密码
     */
    public function verifyPassword($userId, $password) {
        // 从数据库获取哈希
        $storedHash = $this->getFromDatabase($userId);
        if (!$storedHash) {
            return false;
        }
        
        // 预处理输入密码
        $processedPassword = $this->applyPepper($password);
        
        // 验证密码
        $isValid = $this->hasher->verify($processedPassword, $storedHash);
        
        // 如果验证成功且需要重新哈希，则更新哈希
        if ($isValid && $this->hasher->needsRehash($storedHash)) {
            $this->storePassword($userId, $password);
        }
        
        // 如果使用旧算法，升级到新算法
        if ($isValid && $this->isOldAlgorithm($storedHash)) {
            $this->upgradePasswordHash($userId, $password);
        }
        
        return $isValid;
    }
    
    /**
     * 应用胡椒
     */
    private function applyPepper($password) {
        if (empty($this->pepper)) {
            return $password;
        }
        
        return hash_hmac('sha256', $password, $this->pepper);
    }
    
    /**
     * 检查是否为旧算法
     */
    private function isOldAlgorithm($hash) {
        // 检查是否为bcrypt成本因子10的哈希
        return strpos($hash, '$2y$10$') === 0;
    }
    
    /**
     * 升级密码哈希
     */
    private function upgradePasswordHash($userId, $password) {
        // 使用新算法重新哈希
        $newHash = $this->hasher->hash($this->applyPepper($password));
        
        // 更新数据库中的哈希
        $this->updateDatabase($userId, $newHash);
        
        return $newHash;
    }
    
    /**
     * 密码重置
     */
    public function resetPassword($userId, $newPassword) {
        // 验证新密码强度
        $strength = BcryptPasswordHasher::evaluatePasswordStrength($newPassword);
        if ($strength['score'] < 50) {
            throw new InvalidArgumentException('Password is too weak: ' . implode(', ', $strength['feedback']));
        }
        
        // 存储新密码
        return $this->storePassword($userId, $newPassword);
    }
    
    /**
     * 模拟数据库操作
     */
    private function saveToDatabase($userId, $hash) {
        // 在实际应用中，这里会是真实的数据库操作
        $_SESSION['user_passwords'][$userId] = $hash;
    }
    
    private function getFromDatabase($userId) {
        return $_SESSION['user_passwords'][$userId] ?? null;
    }
    
    private function updateDatabase($userId, $hash) {
        $_SESSION['user_passwords'][$userId] = $hash;
    }
    
    /**
     * 密码策略管理
     */
    public static function getPasswordPolicy() {
        return [
            'min_length' => 8,
            'max_length' => 128,
            'require_uppercase' => true,
            'require_lowercase' => true,
            'require_numbers' => true,
            'require_special_chars' => true,
            'prevent_common_passwords' => true,
            'prevent_user_info_in_password' => true,
            'password_history' => 5, // 记住最近5个密码
            'expiration_days' => 90   // 90天过期
        ];
    }
    
    /**
     * 检查密码是否符合策略
     */
    public static function validatePasswordPolicy($password, $userInfo = []) {
        $policy = self::getPasswordPolicy();
        $errors = [];
        
        // 长度检查
        if (strlen($password) < $policy['min_length']) {
            $errors[] = "密码长度至少{$policy['min_length']}位";
        }
        
        if (strlen($password) > $policy['max_length']) {
            $errors[] = "密码长度不超过{$policy['max_length']}位";
        }
        
        // 字符类型检查
        if ($policy['require_uppercase'] && !preg_match('/[A-Z]/', $password)) {
            $errors[] = '密码必须包含大写字母';
        }
        
        if ($policy['require_lowercase'] && !preg_match('/[a-z]/', $password)) {
            $errors[] = '密码必须包含小写字母';
        }
        
        if ($policy['require_numbers'] && !preg_match('/[0-9]/', $password)) {
            $errors[] = '密码必须包含数字';
        }
        
        if ($policy['require_special_chars'] && !preg_match('/[^A-Za-z0-9]/', $password)) {
            $errors[] = '密码必须包含特殊字符';
        }
        
        // 常见密码检查
        if ($policy['prevent_common_passwords']) {
            $commonPasswords = ['123456', 'password', 'qwerty', 'admin123'];
            if (in_array(strtolower($password), $commonPasswords)) {
                $errors[] = '密码过于常见，请选择更复杂的密码';
            }
        }
        
        // 用户信息检查
        if ($policy['prevent_user_info_in_password'] && !empty($userInfo)) {
            foreach ($userInfo as $info) {
                if (stripos($password, $info) !== false) {
                    $errors[] = '密码不能包含用户信息';
                    break;
                }
            }
        }
        
        return $errors;
    }
}

// 使用示例
// session_start();
// 
// $passwordStorage = new SecurePasswordStorage('argon2', 'my_pepper_key');
// 
// // 存储密码
// $userId = 123;
// $password = 'SecurePass123!';
// 
// try {
//     // 验证密码策略
//     $policyErrors = SecurePasswordStorage::validatePasswordPolicy($password, ['john', 'doe']);
//     if (!empty($policyErrors)) {
//         echo "密码策略违规: " . implode(', ', $policyErrors) . "\n";
//     } else {
//         // 存储密码
//         $hash = $passwordStorage->storePassword($userId, $password);
//         echo "Password stored successfully: $hash\n";
//         
//         // 验证密码
//         if ($passwordStorage->verifyPassword($userId, $password)) {
//             echo "Password verification successful\n";
//         } else {
//             echo "Password verification failed\n";
//         }
//     }
// } catch (Exception $e) {
//     echo "Error: " . $e->getMessage() . "\n";
// }
?>
```

### 密码安全传输

```php
<?php
/**
 * 密码安全传输处理
 */
class SecurePasswordTransmission {
    
    /**
     * 客户端密码预处理
     */
    public static function clientSideHashing() {
        return '
<!-- 客户端JavaScript密码处理 -->
<script>
// 客户端密码哈希（仅作为额外保护层）
async function hashPassword(password) {
    // 使用Web Crypto API
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
}

// 表单提交处理
document.getElementById("loginForm").addEventListener("submit", async function(e) {
    e.preventDefault();
    
    const passwordInput = document.getElementById("password");
    const hashedPassword = await hashPassword(passwordInput.value);
    
    // 清空明文密码
    passwordInput.value = "";
    
    // 添加隐藏字段
    const hiddenField = document.createElement("input");
    hiddenField.type = "hidden";
    hiddenField.name = "hashed_password";
    hiddenField.value = hashedPassword;
    this.appendChild(hiddenField);
    
    // 提交表单
    this.submit();
});
</script>';
    }
    
    /**
     * 服务端传输安全处理
     */
    public static function serverSideSecurity() {
        return [
            'https_requirement' => '强制使用HTTPS传输',
            'hsts' => '启用HTTP Strict Transport Security',
            'secure_headers' => '设置安全HTTP头部',
            'input_sanitization' => '输入验证和清理',
            'rate_limiting' => '实施速率限制'
        ];
    }
    
    /**
     * HTTPS安全配置
     */
    public static function httpsSecurityConfig() {
        return '
# Apache HTTPS配置示例
<VirtualHost *:443>
    ServerName example.com
    
    # SSL配置
    SSLEngine on
    SSLCertificateFile /path/to/certificate.crt
    SSLCertificateKeyFile /path/to/private.key
    SSLCertificateChainFile /path/to/chain.pem
    
    # 安全协议和密码套件
    SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
    SSLCipherSuite ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
    
    # HSTS头部
    Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
    
    # 其他安全头部
    Header always set X-Content-Type-Options nosniff
    Header always set X-Frame-Options DENY
    Header always set X-XSS-Protection "1; mode=block"
</VirtualHost>';
    }
    
    /**
     * 密码重置安全处理
     */
    public static function securePasswordReset() {
        class PasswordResetHandler {
            private $resetTokens = [];
            
            /**
             * 生成安全的重置令牌
             */
            public function generateResetToken($userId) {
                $token = bin2hex(random_bytes(32));
                $expiry = time() + 3600; // 1小时过期
                
                $this->resetTokens[$token] = [
                    'user_id' => $userId,
                    'expiry' => $expiry,
                    'used' => false
                ];
                
                return $token;
            }
            
            /**
             * 验证重置令牌
             */
            public function validateResetToken($token) {
                if (!isset($this->resetTokens[$token])) {
                    return false;
                }
                
                $tokenData = $this->resetTokens[$token];
                
                // 检查是否过期
                if (time() > $tokenData['expiry']) {
                    unset($this->resetTokens[$token]);
                    return false;
                }
                
                // 检查是否已使用
                if ($tokenData['used']) {
                    return false;
                }
                
                return $tokenData;
            }
            
            /**
             * 使用重置令牌
             */
            public function useResetToken($token) {
                if (!isset($this->resetTokens[$token])) {
                    return false;
                }
                
                $this->resetTokens[$token]['used'] = true;
                $userId = $this->resetTokens[$token]['user_id'];
                
                // 使令牌过期
                $this->resetTokens[$token]['expiry'] = time() - 1;
                
                return $userId;
            }
            
            /**
             * 发送重置邮件
             */
            public function sendResetEmail($email, $token) {
                $resetUrl = "https://example.com/reset-password?token=$token";
                $subject = "密码重置";
                $message = "请点击以下链接重置您的密码：\n$resetUrl\n\n此链接将在1小时后过期。";
                
                // 发送邮件（实际应用中使用邮件库）
                mail($email, $subject, $message);
            }
        }
        
        return new PasswordResetHandler();
    }
}

// 使用示例
// $resetHandler = SecurePasswordTransmission::securePasswordReset();
// $token = $resetHandler->generateResetToken(123);
// $resetHandler->sendResetEmail('user@example.com', $token);
?>
```

### 密码安全管理最佳实践

```php
<?php
/**
 * 密码安全管理最佳实践
 */
class PasswordSecurityBestPractices {
    
    /**
     * 密码存储最佳实践
     */
    public static function storageBestPractices() {
        return [
            'use_strong_algorithms' => [
                'description' => '使用强哈希算法',
                'details' => '优先使用Argon2，其次bcrypt，避免MD5/SHA1等快速哈希'
            ],
            'unique_salts' => [
                'description' => '为每个密码生成唯一盐值',
                'details' => '让相同密码产生不同哈希，防止彩虹表攻击'
            ],
            'appropriate_cost' => [
                'description' => '设置适当的计算成本',
                'details' => '平衡安全性和性能，通常0.5-1秒的哈希时间'
            ],
            'regular_updates' => [
                'description' => '定期更新安全参数',
                'details' => '随着硬件性能提升调整算法参数'
            ],
            'pepper_usage' => [
                'description' => '使用胡椒（可选）',
                'details' => '额外的全局密钥，存储在应用配置中'
            ]
        ];
    }
    
    /**
     * 密码策略最佳实践
     */
    public static function policyBestPractices() {
        return [
            'minimum_length' => [
                'description' => '设置最小长度',
                'recommendation' => '至少12位，推荐16位以上'
            ],
            'complexity_requirements' => [
                'description' => '复杂性要求',
                'recommendation' => '包含大小写字母、数字、特殊字符'
            ],
            'password_blacklist' => [
                'description' => '禁止常见密码',
                'recommendation' => '维护常见弱密码黑名单'
            ],
            'rotation_policy' => [
                'description' => '定期更换',
                'recommendation' => '90-365天更换一次'
            ],
            'history_check' => [
                'description' => '历史密码检查',
                'recommendation' => '禁止使用最近几次的密码'
            ]
        ];
    }
    
    /**
     * 传输安全最佳实践
     */
    public static function transmissionBestPractices() {
        return [
            'mandatory_https' => [
                'description' => '强制HTTPS',
                'details' => '所有密码相关传输必须使用HTTPS'
            ],
            'hsts_implementation' => [
                'description' => '实施HSTS',
                'details' => '防止SSL剥离攻击'
            ],
            'secure_headers' => [
                'description' => '安全头部',
                'details' => '设置适当的HTTP安全头部'
            ],
            'input_validation' => [
                'description' => '输入验证',
                'details' => '严格验证和清理用户输入'
            ],
            'rate_limiting' => [
                'description' => '速率限制',
                'details' => '防止暴力破解和DoS攻击'
            ]
        ];
    }
    
    /**
     * 监控和审计最佳实践
     */
    public static function monitoringBestPractices() {
        return [
            'logging' => [
                'description' => '安全日志记录',
                'details' => '记录所有认证相关事件'
            ],
            'anomaly_detection' => [
                'description' => '异常检测',
                'details' => '监控异常登录模式'
            ],
            'breach_monitoring' => [
                'description' => '泄露监控',
                'details' => '监控公共泄露数据库'
            ],
            'regular_audits' => [
                'description' => '定期审计',
                'details' => '审查密码安全策略和实现'
            ],
            'incident_response' => [
                'description' => '应急响应',
                'details' => '建立密码泄露应急处理流程'
            ]
        ];
    }
    
    /**
     * 密码安全审计工具
     */
    public static function securityAudit() {
        class PasswordSecurityAuditor {
            
            /**
             * 审计密码哈希强度
             */
            public function auditPasswordHashes($hashes) {
                $results = [
                    'total' => count($hashes),
                    'weak_hashes' => 0,
                    'strong_hashes' => 0,
                    'needs_upgrade' => 0,
                    'issues' => []
                ];
                
                foreach ($hashes as $userId => $hash) {
                    if (strpos($hash, '$2y$') === 0) {
                        // bcrypt哈希
                        $results['strong_hashes']++;
                        
                        // 检查成本因子
                        preg_match('/\$2y\$(\d+)/', $hash, $matches);
                        $cost = (int)($matches[1] ?? 0);
                        if ($cost < 12) {
                            $results['needs_upgrade']++;
                            $results['issues'][] = "User $userId: bcrypt cost factor too low ($cost)";
                        }
                    } elseif (strpos($hash, '$argon2id$') === 0) {
                        // Argon2id哈希
                        $results['strong_hashes']++;
                    } else {
                        // 弱哈希或明文
                        $results['weak_hashes']++;
                        $results['issues'][] = "User $userId: weak or plaintext password detected";
                    }
                }
                
                return $results;
            }
            
            /**
             * 生成安全报告
             */
            public function generateSecurityReport($auditResults) {
                $report = "密码安全审计报告\n";
                $report .= "==================\n\n";
                
                $report .= "总用户数: {$auditResults['total']}\n";
                $report .= "强哈希数: {$auditResults['strong_hashes']}\n";
                $report .= "弱哈希数: {$auditResults['weak_hashes']}\n";
                $report .= "需要升级: {$auditResults['needs_upgrade']}\n\n";
                
                if (!empty($auditResults['issues'])) {
                    $report .= "发现的问题:\n";
                    foreach ($auditResults['issues'] as $issue) {
                        $report .= "- $issue\n";
                    }
                }
                
                return $report;
            }
        }
        
        return new PasswordSecurityAuditor();
    }
    
    /**
     * 密码安全培训材料
     */
    public static function userEducation() {
        return [
            'strong_password_tips' => [
                '使用至少12位长度的密码',
                '包含大小写字母、数字和特殊字符',
                '避免使用个人信息和常见词汇',
                '使用密码管理器生成和存储密码',
                '定期更换重要账户密码'
            ],
            'safe_practices' => [
                '不在多个网站使用相同密码',
                '不在不安全的网络环境下输入密码',
                '警惕钓鱼网站和邮件',
                '启用双因素认证',
                '及时更新软件和浏览器'
            ]
        ];
    }
}

// 使用示例
// $auditor = PasswordSecurityBestPractices::securityAudit();
// 
// // 模拟数据库中的密码哈希
// $passwordHashes = [
//     1 => '$2y$10$example_bcrypt_hash',
//     2 => '$2y$12$example_bcrypt_hash',
//     3 => '$argon2id$v=19$m=65536,t=4,p=3$example_argon2_hash',
//     4 => 'plaintext_password' // 弱密码示例
// ];
// 
// $auditResults = $auditor->auditPasswordHashes($passwordHashes);
// $report = $auditor->generateSecurityReport($auditResults);
// echo $report;
?>
```

### 密码安全总结

1. **存储安全**：
   - 使用bcrypt、Argon2等强哈希算法
   - 为每个密码生成唯一盐值
   - 设置适当的计算复杂度
   - 定期更新安全参数

2. **策略管理**：
   - 实施强密码策略
   - 定期更换密码
   - 维护密码历史记录
   - 禁止常见弱密码

3. **传输安全**：
   - 强制使用HTTPS
   - 实施HSTS
   - 设置安全HTTP头部
   - 输入验证和速率限制

4. **监控审计**：
   - 记录安全事件日志
   - 监控异常登录行为
   - 定期进行安全审计
   - 建立应急响应机制

### 总结

密码安全存储是Web应用安全的基础，需要从算法选择、参数配置、策略管理、传输安全等多个维度综合考虑。通过使用现代的密码哈希算法、实施严格的密码策略、确保安全传输和建立完善的监控机制，可以有效保护用户密码安全。开发人员应该持续关注密码安全领域的最新发展，及时更新安全措施以应对不断演变的安全威胁。